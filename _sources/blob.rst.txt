.. Automatically generated by code2rst.py
   code2rst.py src/blob.c doc/blob.rst
   Edit src/blob.c not this file!

.. currentmodule:: apsw

.. _blobio:

Blob Input/Output
*****************

A `blob <http://en.wikipedia.org/wiki/Binary_large_object>`_ is a
SQLite `datatype <https://sqlite.org/datatype3.html>`_ representing
a sequence of bytes.  It can be zero or more bytes in size.

SQLite blobs have an absolute maximum size of 2GB and a `default
maximum size <https://sqlite.org/c3ref/c_limit_attached.html>`_ of
1GB.

An alternate approach to using blobs is to store the data in files and
store the filename in the database.  Doing so loses the `ACID
<https://sqlite.org/transactional.html>`_ properties of SQLite.

zeroblob class
==============

.. class:: zeroblob(size: int)

  If you want to insert a blob into a row, you previously needed to
  supply the entire blob in one go.  To read just one byte also
  required retrieving the blob in its entirety. For example to insert
  a 100MB file you would have done::

     largedata=open("largefile", "rb").read()
     cur.execute("insert into foo values(?)", (largedata,))

  SQLite 3.5 allowed for incremental Blob I/O so you can read and
  write blobs in small amounts.  You cannot change the size of a blob
  so you need to reserve space which you do through zeroblob which
  creates a blob of the specified size but full of zero bytes.  For
  example you would reserve space for your 100MB one of these two
  ways::

    cur.execute("insert into foo values(zeroblob(100000000))")
    cur.execute("insert into foo values(?),
                 (apsw.zeroblob(100000000),))

  This class is used for the second way.  Once a blob exists in the
  database, you then use the :class:`blob` class to read and write its
  contents.

.. method:: zeroblob.length() -> int

  Size of zero blob in bytes.

Blob class
==========

.. class:: Blob

  This object is created by :meth:`Connection.blobopen` and provides
  access to a blob in the database.  It behaves like a Python file.
  At the C level it wraps a `sqlite3_blob
  <https://sqlite.org/c3ref/blob.html>`_.

  .. note::

    You cannot change the size of a blob using this object. You should
    create it with the correct size in advance either by using
    :class:`zeroblob` or the `zeroblob()
    <https://sqlite.org/lang_corefunc.html>`_ function.

  See the :ref:`example <example-blobio>`.

.. method:: Blob.__enter__() -> Blob

  You can use a blob as a `context manager
  <http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_
  as defined in :pep:`0343`.  When you use *with* statement,
  the blob is always :meth:`closed <~blob.close>` on exit from the block, even if an
  exception occurred in the block.

  For example::

    with connection.blobopen() as blob:
        blob.write("...")
        res=blob.read(1024)

.. method:: Blob.__exit__() -> Literal[False]

  Implements context manager in conjunction with
  :meth:`~blob.__enter__`.  Any exception that happened in the
  *with* block is raised after closing the blob.

.. index:: sqlite3_blob_close

.. method:: Blob.close(force: bool = False) -> None

  Closes the blob.  Note that even if an error occurs the blob is
  still closed.

  .. note::

     In some cases errors that technically occurred in the
     :meth:`~blob.read` and :meth:`~blob.write` routines may not be
     reported until close is called.  Similarly errors that occurred
     in those methods (eg calling :meth:`~blob.write` on a read-only
     blob) may also be re-reported in :meth:`~blob.close`.  (This
     behaviour is what the underlying SQLite APIs do - it is not APSW
     doing it.)

  It is okay to call :meth:`~blob.close` multiple times.

  :param force: Ignores any errors during close.

  Calls: `sqlite3_blob_close <https://sqlite.org/c3ref/blob_close.html>`__

.. index:: sqlite3_blob_bytes

.. method:: Blob.length() -> int

  Returns the size of the blob in bytes.

  Calls: `sqlite3_blob_bytes <https://sqlite.org/c3ref/blob_bytes.html>`__

.. index:: sqlite3_blob_read

.. method:: Blob.read(length: int = -1) -> bytes

  Reads amount of data requested, or till end of file, whichever is
  earlier. Attempting to read beyond the end of the blob returns an
  empty bytes in the same manner as end of file on normal file
  objects.  Negative numbers read remaining data.

  Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__

.. index:: sqlite3_blob_read

.. method:: Blob.readinto(buffer, offset: int = 0, length: int = -1) -> None

  Reads from the blob into a buffer you have supplied.  This method is
  useful if you already have a buffer like object that data is being
  assembled in, and avoids allocating results in :meth:`blob.read` and
  then copying into buffer.

  :param buffer: A writable buffer like object.
                 There is a bytearray type that is very useful.
                 :class:`array.array` also works.

  :param offset: The position to start writing into the buffer
                 defaulting to the beginning.

  :param length: How much of the blob to read.  The default is the
                 remaining space left in the buffer.  Note that if
                 there is more space available than blob left then you
                 will get a :exc:`ValueError` exception.

  Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__

.. index:: sqlite3_blob_reopen

.. method:: Blob.reopen(rowid: int) -> None

  Change this blob object to point to a different row.  It can be
  faster than closing an existing blob an opening a new one.

  Calls: `sqlite3_blob_reopen <https://sqlite.org/c3ref/blob_reopen.html>`__

.. method:: Blob.seek(offset: int, whence: int = 0) -> None

  Changes current position to *offset* biased by *whence*.

  :param offset: New position to seek to.  Can be positive or negative number.
  :param whence: Use 0 if *offset* is relative to the beginning of the blob,
                 1 if *offset* is relative to the current position,
                 and 2 if *offset* is relative to the end of the blob.
  :raises ValueError: If the resulting offset is before the beginning (less than zero) or beyond the end of the blob.

.. method:: Blob.tell() -> int

  Returns the current offset.

.. index:: sqlite3_blob_write

.. method:: Blob.write(data: bytes) -> None

  Writes the data to the blob.

  :param data: bytes to write

  :raises TypeError: Wrong data type

  :raises ValueError: If the data would go beyond the end of the blob.
      You cannot increase the size of a blob by writing beyond the end.
      You need to use :class:`zeroblob` to set the desired size first when
      inserting the blob.

  Calls: `sqlite3_blob_write <https://sqlite.org/c3ref/blob_write.html>`__

