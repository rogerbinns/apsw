.. Automatically generated by code2rst.py
   Edit src/blob.c not this file!

.. currentmodule:: apsw

.. _blobio:

Blob Input/Output
*****************

A `blob <https://en.wikipedia.org/wiki/Binary_large_object>`_ is a
SQLite `datatype <https://sqlite.org/datatype3.html>`_ representing
a sequence of bytes.  It can be zero or more bytes in size.  Blobs
cannot be resized, but you can read and overwrite parts of them.

SQLite blobs have an absolute maximum size of 2GB and a `default
maximum size <https://sqlite.org/c3ref/c_limit_attached.html>`_ of
1GB.

An alternate approach to using blobs is to store the data in files and
store the filename in the database.  Doing so loses the `ACID
<https://sqlite.org/transactional.html>`_ properties of SQLite.
There are `benchmarks <https://www.sqlite.org/fasterthanfs.html>`__.

zeroblob class
==============

.. class:: zeroblob(size: int)

  If you want to insert a blob into a row, you need to
  supply the entire blob in one go.  Using this class or
  `function <https://www.sqlite.org/lang_corefunc.html#zeroblob>`__
  allocates the space in the database filling it with zeroes.

  You can then overwrite parts in smaller chunks, without having
  to do it all at once.  The :ref:`example <example_blob_io>` shows
  how to use it.

  :param size: Number of zeroed bytes to create

.. method:: zeroblob.length() -> int

  Size of zero blob in bytes.

Blob class
==========

.. class:: Blob

  This object is created by :meth:`Connection.blob_open` and provides
  access to a blob in the database.  It behaves like a Python file.
  It wraps a `sqlite3_blob
  <https://sqlite.org/c3ref/blob.html>`_.

  .. note::

    You cannot change the size of a blob using this object. You should
    create it with the correct size in advance either by using
    :class:`zeroblob` or the `zeroblob()
    <https://sqlite.org/lang_corefunc.html>`_ function.

  See the :ref:`example <example_blob_io>`.

.. method:: Blob.__enter__() -> Blob

  You can use a blob as a `context manager
  <https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers>`_
  as defined in :pep:`0343`.  When you use *with* statement,
  the blob is always :meth:`closed <Blob.close>` on exit from the block, even if an
  exception occurred in the block.

  For example::

    with connection.blob_open() as blob:
        blob.write("...")
        res=blob.read(1024)

.. method:: Blob.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]

  Implements context manager in conjunction with
  :meth:`~Blob.__enter__`.  Any exception that happened in the
  *with* block is raised after closing the blob.

.. index:: sqlite3_blob_close

.. method:: Blob.close(force: bool = False) -> None

  Closes the blob.  Note that even if an error occurs the blob is
  still closed.

  .. note::

     In some cases errors that technically occurred in the
     :meth:`~Blob.read` and :meth:`~Blob.write` routines may not be
     reported until close is called.  Similarly errors that occurred
     in those methods (eg calling :meth:`~Blob.write` on a read-only
     blob) may also be re-reported in :meth:`~Blob.close`.  (This
     behaviour is what the underlying SQLite APIs do - it is not APSW
     doing it.)

  It is okay to call :meth:`~Blob.close` multiple times.

  :param force: Ignores any errors during close.

  Calls: `sqlite3_blob_close <https://sqlite.org/c3ref/blob_close.html>`__

.. index:: sqlite3_blob_bytes

.. method:: Blob.length() -> int

  Returns the size of the blob in bytes.

  Calls: `sqlite3_blob_bytes <https://sqlite.org/c3ref/blob_bytes.html>`__

.. index:: sqlite3_blob_read

.. method:: Blob.read(length: int = -1) -> bytes

  Reads amount of data requested, or till end of file, whichever is
  earlier. Attempting to read beyond the end of the blob returns an
  empty bytes in the same manner as end of file on normal file
  objects.  Negative numbers read all remaining data.

  Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__

.. index:: sqlite3_blob_read

.. method:: Blob.read_into(buffer: bytearray |  array.array[Any] | memoryview, offset: int = 0, length: int = -1) -> None

  Reads from the blob into a buffer you have supplied.  This method is
  useful if you already have a buffer like object that data is being
  assembled in, and avoids allocating results in :meth:`Blob.read` and
  then copying into buffer.

  :param buffer: A writable buffer like object.
                 There is a :class:`bytearray` type that is very useful.
                 :mod:`Arrays <array>` also work.

  :param offset: The position to start writing into the buffer
                 defaulting to the beginning.

  :param length: How much of the blob to read.  The default is the
                 remaining space left in the buffer.  Note that if
                 there is more space available than blob left then you
                 will get a *ValueError* exception.

  Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__

.. index:: sqlite3_blob_reopen

.. method:: Blob.reopen(rowid: int) -> None

  Change this blob object to point to a different row.  It can be
  faster than closing an existing blob an opening a new one.

  Calls: `sqlite3_blob_reopen <https://sqlite.org/c3ref/blob_reopen.html>`__

.. method:: Blob.seek(offset: int, whence: int = 0) -> None

  Changes current position to *offset* biased by *whence*.

  :param offset: New position to seek to.  Can be positive or negative number.
  :param whence: Use 0 if *offset* is relative to the beginning of the blob,
                 1 if *offset* is relative to the current position,
                 and 2 if *offset* is relative to the end of the blob.
  :raises ValueError: If the resulting offset is before the beginning (less than zero) or beyond the end of the blob.

.. method:: Blob.tell() -> int

  Returns the current offset.

.. index:: sqlite3_blob_write

.. method:: Blob.write(data: collections.abc.Buffer) -> None

  Writes the data to the blob.

  :param data: Buffer to write

  :raises TypeError: Wrong data type

  :raises ValueError: If the data would go beyond the end of the blob.
      You cannot increase the size of a blob by writing beyond the end.
      You need to use :class:`zeroblob` to set the desired size first when
      inserting the blob.

  Calls: `sqlite3_blob_write <https://sqlite.org/c3ref/blob_write.html>`__

