/* This file is generated by gendocstrings.py */

#ifndef __GNUC__
#define __builtin_types_compatible_p(x,y) (1)
#endif

#define  Apsw_allow_missing_dict_bindings_DOC "apsw.allow_missing_dict_bindings(value: bool) -> bool\n\n" \
"Changes how missing bindings are handled when using a :class:`dict`.\n" \
"Historically missing bindings were treated as *None*.  It was\n" \
"anticipated that dict bindings would be used when there were lots\n" \
"of columns, so having missing ones defaulting to *None* was\n" \
"convenient.\n" \
"\n" \
"Unfortunately this also has the side effect of not catching typos\n" \
"and similar issues.\n" \
"\n" \
"APSW 3.41.0.0 changed the default so that missing dict entries\n" \
"will result in an exception.  Call this with *True* to restore\n" \
"the earlier behaviour, and *False* to have an exception.\n" \
"\n" \
"The previous value is returned.\n" 

#define Apsw_allow_missing_dict_bindings_KWNAMES "value"
#define Apsw_allow_missing_dict_bindings_USAGE "apsw.allow_missing_dict_bindings(value: bool) -> bool"

#define Apsw_allow_missing_dict_bindings_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(value), int)); \
} while(0)


#define  Apsw_apsw_version_DOC "apsw.apsw_version() -> str\n\n" \
"Returns the APSW version.\n" 

#define Apsw_apsw_version_OLDNAME "apswversion"
#define Apsw_apsw_version_USAGE "apsw.apsw_version() -> str"
#define Apsw_apsw_version_OLDDOC Apsw_apsw_version_USAGE "\n(Old less clear name apswversion)"

#define  Apsw_complete_DOC "apsw.complete(statement: str) -> bool\n\n" \
"Returns True if the input string comprises one or more complete SQL\n" \
"statements by looking for an unquoted trailing semi-colon.  It does\n" \
"not consider comments or blank lines to be complete.\n" \
"\n" \
"An example use would be if you were prompting the user for SQL\n" \
"statements and needed to know if you had a whole statement, or\n" \
"needed to ask for another line::\n" \
"\n" \
"  statement = input(\"SQL> \")\n" \
"  while not apsw.complete(statement):\n" \
"     more = input(\"  .. \")\n" \
"     statement = statement + \"\\n\" + more\n" \
"\n" \
"Calls: `sqlite3_complete <https://sqlite.org/c3ref/complete.html>`__\n" 

#define Apsw_complete_KWNAMES "statement"
#define Apsw_complete_USAGE "apsw.complete(statement: str) -> bool"

#define Apsw_complete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statement), const char *)); \
} while(0)


#define  Apsw_config_DOC "apsw.config(op: int, *args: Any) -> None\n\n" \
":param op: A `configuration operation <https://sqlite.org/c3ref/c_config_chunkalloc.html>`_\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"Some operations don't make sense from a Python program.  All the\n" \
"remaining are supported.\n" \
"\n" \
"Calls: `sqlite3_config <https://sqlite.org/c3ref/config.html>`__\n" 

#define  Apsw_connections_DOC "apsw.connections() -> list[Connection]\n\n" \
"Returns a list of the connections\n" 

#define  Apsw_enable_shared_cache_DOC "apsw.enable_shared_cache(enable: bool) -> None\n\n" \
"`Discouraged\n" \
"<https://sqlite.org/sharedcache.html#use_of_shared_cache_is_discouraged>`__.\n" \
"\n" \
"Calls: `sqlite3_enable_shared_cache <https://sqlite.org/c3ref/enable_shared_cache.html>`__\n" 

#define Apsw_enable_shared_cache_KWNAMES "enable"
#define Apsw_enable_shared_cache_USAGE "apsw.enable_shared_cache(enable: bool) -> None"

#define Apsw_enable_shared_cache_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define Apsw_enable_shared_cache_OLDNAME "enablesharedcache"
#define Apsw_enable_shared_cache_OLDDOC Apsw_enable_shared_cache_USAGE "\n(Old less clear name enablesharedcache)"

#define  Apsw_exception_for_DOC "apsw.exception_for(code: int) -> Exception\n\n" \
"If you would like to raise an exception that corresponds to a\n" \
"particular SQLite `error code\n" \
"<https://sqlite.org/c3ref/c_abort.html>`_ then call this function.\n" \
"It also understands `extended error codes\n" \
"<https://sqlite.org/c3ref/c_ioerr_access.html>`_.\n" \
"\n" \
"For example to raise `SQLITE_IOERR_ACCESS <https://sqlite.org/c3ref/c_ioerr_access.html>`_::\n" \
"\n" \
"  raise apsw.exception_for(apsw.SQLITE_IOERR_ACCESS)\n" 

#define Apsw_exception_for_KWNAMES "code"
#define Apsw_exception_for_USAGE "apsw.exception_for(code: int) -> Exception"

#define Apsw_exception_for_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(code), int)); \
} while(0)


#define Apsw_exception_for_OLDNAME "exceptionfor"
#define Apsw_exception_for_OLDDOC Apsw_exception_for_USAGE "\n(Old less clear name exceptionfor)"

#define  Apsw_fork_checker_DOC "apsw.fork_checker() -> None\n\n" \
"**Note** This method is not available on Windows as it does not\n" \
"support the fork system call.\n" \
"\n" \
"SQLite does not allow the use of database connections across `forked\n" \
"<https://en.wikipedia.org/wiki/Fork_(operating_system)>`__ processes\n" \
"(see the `SQLite FAQ Q6 <https://sqlite.org/faq.html#q6>`__).\n" \
"(Forking creates a child process that is a duplicate of the parent\n" \
"including the state of all data structures in the program.  If you\n" \
"do this to SQLite then parent and child would both consider\n" \
"themselves owners of open databases and silently corrupt each\n" \
"other's work and interfere with each other's locks.)\n" \
"\n" \
"One example of how you may end up using fork is if you use the\n" \
":mod:`multiprocessing module <multiprocessing>` which can use\n" \
"fork to make child processes.\n" \
"\n" \
"If you do use fork or multiprocessing on a platform that supports fork\n" \
"then you **must** ensure database connections and their objects\n" \
"(cursors, backup, blobs etc) are not used in the parent process, or\n" \
"are all closed before calling fork or starting a `Process\n" \
"<https://docs.python.org/3/library/multiprocessing.html#process-and-exceptions>`__.\n" \
"(Note you must call close to ensure the underlying SQLite objects are\n" \
"closed.  It is also a good idea to call :func:`gc.collect(2)\n" \
"<gc.collect>` to ensure anything you may have missed is also\n" \
"deallocated.)\n" \
"\n" \
"Once you run this method, extra checking code is inserted into\n" \
"SQLite's mutex operations (at a very small performance penalty) that\n" \
"verifies objects are not used across processes.  You will get a\n" \
":exc:`ForkingViolationError` if you do so.  Note that due to the way\n" \
"Python's internals work, the exception will be delivered to\n" \
":func:`sys.excepthook` in addition to the normal exception mechanisms and\n" \
"may be reported by Python after the line where the issue actually\n" \
"arose.  (Destructors of objects you didn't close also run between\n" \
"lines.)\n" \
"\n" \
"You should only call this method as the first line after importing\n" \
"APSW, as it has to shutdown and re-initialize SQLite.  If you have\n" \
"any SQLite objects already allocated when calling the method then\n" \
"the program will later crash.  The recommended use is to use the fork\n" \
"checking as part of your test suite.\n" 

#define  Apsw_format_sql_value_DOC "apsw.format_sql_value(value: SQLiteValue) -> str\n\n" \
"Returns a Python string representing the supplied value in SQLite\n" \
"syntax.\n" \
"\n" \
"Note that SQLite represents floating point `Nan\n" \
"<https://en.wikipedia.org/wiki/NaN>`__ as :code:`NULL`, infinity as\n" \
":code:`9e999` and loses the sign on `negative zero\n" \
"<https://en.wikipedia.org/wiki/Signed_zero>`__.\n" 

#define  Apsw_hard_heap_limit_DOC "apsw.hard_heap_limit(limit: int) -> int\n\n" \
"Enforces SQLite keeping memory usage below *limit* bytes and\n" \
"returns the previous limit.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    :meth:`soft_heap_limit`\n" \
"\n" \
"Calls: `sqlite3_hard_heap_limit64 <https://sqlite.org/c3ref/hard_heap_limit64.html>`__\n" 

#define Apsw_hard_heap_limit_KWNAMES "limit"
#define Apsw_hard_heap_limit_USAGE "apsw.hard_heap_limit(limit: int) -> int"

#define Apsw_hard_heap_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(limit), long long)); \
} while(0)


#define  Apsw_initialize_DOC "apsw.initialize() -> None\n\n" \
"It is unlikely you will want to call this method as SQLite automatically initializes.\n" \
"\n" \
"Calls: `sqlite3_initialize <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_log_DOC "apsw.log(errorcode: int, message: str) -> None\n\n" \
"Calls the SQLite logging interface.  You must format the\n" \
"message before passing it to this method::\n" \
"\n" \
"    apsw.log(apsw.SQLITE_NOMEM, f\"Need { needed } bytes of memory\")\n" \
"\n" \
"Calls: `sqlite3_log <https://sqlite.org/c3ref/log.html>`__\n" 

#define Apsw_log_KWNAMES "errorcode", "message"
#define Apsw_log_USAGE "apsw.log(errorcode: int, message: str) -> None"

#define Apsw_log_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(errorcode), int)); \
  assert(__builtin_types_compatible_p(typeof(message), const char *)); \
} while(0)


#define  Apsw_memory_high_water_DOC "apsw.memory_high_water(reset: bool = False) -> int\n\n" \
"Returns the maximum amount of memory SQLite has used.  If *reset* is\n" \
"True then the high water mark is reset to the current value.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`status`\n" \
"\n" \
"Calls: `sqlite3_memory_highwater <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define Apsw_memory_high_water_KWNAMES "reset"
#define Apsw_memory_high_water_USAGE "apsw.memory_high_water(reset: bool = False) -> int"

#define Apsw_memory_high_water_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define Apsw_memory_high_water_OLDNAME "memoryhighwater"
#define Apsw_memory_high_water_OLDDOC Apsw_memory_high_water_USAGE "\n(Old less clear name memoryhighwater)"

#define  Apsw_memory_used_DOC "apsw.memory_used() -> int\n\n" \
"Returns the amount of memory SQLite is currently using.\n" \
"\n" \
".. seealso::\n" \
"  :meth:`status`\n" \
"\n" \
"\n" \
"Calls: `sqlite3_memory_used <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define Apsw_memory_used_OLDNAME "memoryused"
#define Apsw_memory_used_USAGE "apsw.memory_used() -> int"
#define Apsw_memory_used_OLDDOC Apsw_memory_used_USAGE "\n(Old less clear name memoryused)"

#define  Apsw_no_change_DOC ":type: object\n" \
"\n" \
"A sentinel value used to indicate no change in a value when\n" \
"used with :meth:`VTCursor.ColumnNoChange`,\n" \
":meth:`VTTable.UpdateChangeRow`, :attr:`TableChange.new`,\n" \
"and :class:`PreUpdate.update`.\n" 

#define  Apsw_pyobject_DOC "apsw.pyobject(object: Any)\n\n" \
"Indicates a Python object is being provided as a\n" \
":ref:`runtime value <pyobject>`.\n" 

#define  Apsw_randomness_DOC "apsw.randomness(amount: int)  -> bytes\n\n" \
"Gets random data from SQLite's random number generator.\n" \
"\n" \
":param amount: How many bytes to return\n" \
"\n" \
"Calls: `sqlite3_randomness <https://sqlite.org/c3ref/randomness.html>`__\n" 

#define Apsw_randomness_KWNAMES "amount"
#define Apsw_randomness_USAGE "apsw.randomness(amount: int)  -> bytes"

#define Apsw_randomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Apsw_release_memory_DOC "apsw.release_memory(amount: int) -> int\n\n" \
"Requests SQLite try to free *amount* bytes of memory.  Returns how\n" \
"many bytes were freed.\n" \
"\n" \
"Calls: `sqlite3_release_memory <https://sqlite.org/c3ref/release_memory.html>`__\n" 

#define Apsw_release_memory_KWNAMES "amount"
#define Apsw_release_memory_USAGE "apsw.release_memory(amount: int) -> int"

#define Apsw_release_memory_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define Apsw_release_memory_OLDNAME "releasememory"
#define Apsw_release_memory_OLDDOC Apsw_release_memory_USAGE "\n(Old less clear name releasememory)"

#define  Apsw_session_config_DOC "apsw.session_config(op: int, *args: Any) -> Any\n\n" \
":param op: One of the `sqlite3session options <https://www.sqlite.org/session/c_session_config_strmsize.html>`__\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
" Calls: `sqlite3session_config <https://sqlite.org/session/sqlite3session_config.html>`__\n" 

#define  Apsw_set_default_vfs_DOC "apsw.set_default_vfs(name: str) -> None\n\n" \
"Sets the default vfs to *name* which must be an existing vfs.\n" \
"See :meth:`vfs_names`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_register <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define Apsw_set_default_vfs_KWNAMES "name"
#define Apsw_set_default_vfs_USAGE "apsw.set_default_vfs(name: str) -> None"

#define Apsw_set_default_vfs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Apsw_shutdown_DOC "apsw.shutdown() -> None\n\n" \
"It is unlikely you will want to call this method and there is no\n" \
"need to do so.  It is a **really** bad idea to call it unless you\n" \
"are absolutely sure all :class:`connections <Connection>`,\n" \
":class:`blobs <Blob>`, :class:`cursors <Cursor>`, :class:`vfs <VFS>`\n" \
"etc have been closed, deleted and garbage collected.\n" \
"\n" \
"Calls: `sqlite3_shutdown <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_sleep_DOC "apsw.sleep(milliseconds: int) -> int\n\n" \
"Sleep for at least the number of `milliseconds`, returning how many\n" \
" milliseconds were requested from the operating system.\n" \
"\n" \
"Calls: `sqlite3_sleep <https://sqlite.org/c3ref/sleep.html>`__\n" 

#define Apsw_sleep_KWNAMES "milliseconds"
#define Apsw_sleep_USAGE "apsw.sleep(milliseconds: int) -> int"

#define Apsw_sleep_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(milliseconds), int)); \
} while(0)


#define  Apsw_soft_heap_limit_DOC "apsw.soft_heap_limit(limit: int) -> int\n\n" \
"Requests SQLite try to keep memory usage below *limit* bytes and\n" \
"returns the previous limit.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    :meth:`hard_heap_limit`\n" \
"\n" \
"Calls: `sqlite3_soft_heap_limit64 <https://sqlite.org/c3ref/hard_heap_limit64.html>`__\n" 

#define Apsw_soft_heap_limit_KWNAMES "limit"
#define Apsw_soft_heap_limit_USAGE "apsw.soft_heap_limit(limit: int) -> int"

#define Apsw_soft_heap_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(limit), long long)); \
} while(0)


#define Apsw_soft_heap_limit_OLDNAME "softheaplimit"
#define Apsw_soft_heap_limit_OLDDOC Apsw_soft_heap_limit_USAGE "\n(Old less clear name softheaplimit)"

#define  Apsw_sqlite3_sourceid_DOC "apsw.sqlite3_sourceid() -> str\n\n" \
"Returns the exact checkin information for the SQLite 3 source\n" \
"being used.\n" \
"\n" \
"Calls: `sqlite3_sourceid <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define  Apsw_sqlite_lib_version_DOC "apsw.sqlite_lib_version() -> str\n\n" \
"Returns the version of the SQLite library.  This value is queried at\n" \
"run time from the library so if you use shared libraries it will be\n" \
"the version in the shared library.\n" \
"\n" \
"Calls: `sqlite3_libversion <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define Apsw_sqlite_lib_version_OLDNAME "sqlitelibversion"
#define Apsw_sqlite_lib_version_USAGE "apsw.sqlite_lib_version() -> str"
#define Apsw_sqlite_lib_version_OLDDOC Apsw_sqlite_lib_version_USAGE "\n(Old less clear name sqlitelibversion)"

#define  Apsw_status_DOC "apsw.status(op: int, reset: bool = False) -> tuple[int, int]\n\n" \
"Returns current and highwater measurements.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_status_malloc_size.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.status` for statistics about a :class:`Connection`\n" \
"  * :ref:`Status example <example_status>`\n" \
"\n" \
"Calls: `sqlite3_status64 <https://sqlite.org/c3ref/status.html>`__\n" 

#define Apsw_status_KWNAMES "op", "reset"
#define Apsw_status_USAGE "apsw.status(op: int, reset: bool = False) -> tuple[int, int]"

#define Apsw_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Apsw_strglob_DOC "apsw.strglob(glob: str, string: str) -> int\n\n" \
"Does string GLOB matching.  Zero is returned on a match.\n" \
"\n" \
"Calls: `sqlite3_strglob <https://sqlite.org/c3ref/strglob.html>`__\n" 

#define Apsw_strglob_KWNAMES "glob", "string"
#define Apsw_strglob_USAGE "apsw.strglob(glob: str, string: str) -> int"

#define Apsw_strglob_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(glob), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string), const char *)); \
} while(0)


#define  Apsw_stricmp_DOC "apsw.stricmp(string1: str, string2: str) -> int\n\n" \
"Does string case-insensitive comparison.  Zero is returned\n" \
"on a match.\n" \
"\n" \
"Calls: `sqlite3_stricmp <https://sqlite.org/c3ref/stricmp.html>`__\n" 

#define Apsw_stricmp_KWNAMES "string1", "string2"
#define Apsw_stricmp_USAGE "apsw.stricmp(string1: str, string2: str) -> int"

#define Apsw_stricmp_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(string1), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string2), const char *)); \
} while(0)


#define  Apsw_strlike_DOC "apsw.strlike(glob: str, string: str, escape: int = 0) -> int\n\n" \
"Does string LIKE matching.  Zero is returned on a match.\n" \
"\n" \
"Calls: `sqlite3_strlike <https://sqlite.org/c3ref/strlike.html>`__\n" 

#define Apsw_strlike_KWNAMES "glob", "string", "escape"
#define Apsw_strlike_USAGE "apsw.strlike(glob: str, string: str, escape: int = 0) -> int"

#define Apsw_strlike_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(glob), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string), const char *)); \
  assert(__builtin_types_compatible_p(typeof(escape), int)); \
  assert(escape == (0)); \
} while(0)


#define  Apsw_strnicmp_DOC "apsw.strnicmp(string1: str, string2: str, count: int) -> int\n\n" \
"Does string case-insensitive comparison.  Zero is returned\n" \
"on a match.\n" \
"\n" \
"Calls: `sqlite3_strnicmp <https://sqlite.org/c3ref/stricmp.html>`__\n" 

#define Apsw_strnicmp_KWNAMES "string1", "string2", "count"
#define Apsw_strnicmp_USAGE "apsw.strnicmp(string1: str, string2: str, count: int) -> int"

#define Apsw_strnicmp_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(string1), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string2), const char *)); \
  assert(__builtin_types_compatible_p(typeof(count), int)); \
} while(0)


#define  Apsw_unregister_vfs_DOC "apsw.unregister_vfs(name: str) -> None\n\n" \
"Unregisters the named vfs.  See :meth:`vfs_names`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_unregister <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define Apsw_unregister_vfs_KWNAMES "name"
#define Apsw_unregister_vfs_USAGE "apsw.unregister_vfs(name: str) -> None"

#define Apsw_unregister_vfs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Apsw_vfs_details_DOC "apsw.vfs_details() -> list[dict[str, int | str]]\n\n" \
"Returns a list with details of each :ref:`vfs <vfs>`.  The detail is a\n" \
"dictionary with the keys being the names of the `sqlite3_vfs\n" \
"<https://sqlite.org/c3ref/vfs.html>`__ data structure, and their\n" \
"corresponding values.\n" \
"\n" \
"Pointers are converted using :c:func:`PyLong_FromVoidPtr`.\n" \
"\n" \
"Calls: `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define  Apsw_vfs_names_DOC "apsw.vfs_names() -> list[str]\n\n" \
"Returns a list of the currently installed :ref:`vfs <vfs>`.  The first\n" \
"item in the list is the default vfs.\n" \
"\n" \
"Calls: `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define Apsw_vfs_names_OLDNAME "vfsnames"
#define Apsw_vfs_names_USAGE "apsw.vfs_names() -> list[str]"
#define Apsw_vfs_names_OLDDOC Apsw_vfs_names_USAGE "\n(Old less clear name vfsnames)"

#define  Backup_class_DOC "You create a backup instance by calling :meth:`Connection.backup`.\n" 

#define  Backup_close_DOC "Backup.close(force: bool = False) -> None\n\n" \
"Does the same thing as :meth:`~Backup.finish`.  This extra api is\n" \
"provided to give the same api as other APSW objects and files.\n" \
"It is safe to call this method multiple  times.\n" \
"\n" \
":param force: If true then any exceptions are ignored.\n" 

#define Backup_close_KWNAMES "force"
#define Backup_close_USAGE "Backup.close(force: bool = False) -> None"

#define Backup_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Backup_done_DOC ":type: bool\n" \
"\n" \
"A boolean that is True if the copy completed in the last call to :meth:`~Backup.step`.\n" 

#define  Backup_enter_DOC "Backup.__enter__() -> Backup\n\n" \
"You can use the backup object as a `context manager\n" \
"<https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  The :meth:`~Backup.__exit__` method ensures that backup\n" \
"is :meth:`finished <Backup.finish>`.\n" 

#define  Backup_exit_DOC "Backup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with :meth:`~Backup.__enter__` ensuring\n" \
"that the copy is :meth:`finished <Backup.finish>`.\n" 

#define Backup_exit_KWNAMES "etype", "evalue", "etraceback"
#define Backup_exit_USAGE "Backup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]"

#define Backup_exit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(etype), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(evalue), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(etraceback), PyObject *)); \
} while(0)


#define  Backup_finish_DOC "Backup.finish() -> None\n\n" \
"Completes the copy process.  If all pages have been copied then the\n" \
"transaction is committed on the destination database, otherwise it\n" \
"is rolled back.  This method must be called for your backup to take\n" \
"effect.  The backup object will always be finished even if there is\n" \
"an exception.  It is safe to call this method multiple times.\n" \
"\n" \
"Calls: `sqlite3_backup_finish <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish>`__\n" 

#define  Backup_page_count_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were in the source database after the last\n" \
"step.  If you haven't called :meth:`~Backup.step` or the backup\n" \
"object has been :meth:`finished <Backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_pagecount <https://sqlite.org/c3ref/backup_finish.html#sqlite3backuppagecount>`__\n" 

#define Backup_page_count_OLDNAME "pagecount"
#define Backup_page_count_USAGE "Backup.page_count"
#define Backup_page_count_OLDDOC Backup_page_count_USAGE "\n(Old less clear name pagecount)"

#define  Backup_remaining_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were remaining to be copied after the last\n" \
"step.  If you haven't called :meth:`~Backup.step` or the backup\n" \
"object has been :meth:`finished <Backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_remaining <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupremaining>`__\n" 

#define  Backup_step_DOC "Backup.step(npages: int = -1) -> bool\n\n" \
"Copies *npages* pages from the source to destination database.  The source database is locked during the copy so\n" \
"using smaller values allows other access to the source database.  The destination database is always locked until the\n" \
"backup object is :meth:`finished <Backup.finish>`.\n" \
"\n" \
":param npages: How many pages to copy. If the parameter is omitted\n" \
"   or negative then all remaining pages are copied.\n" \
"\n" \
"This method may throw a :exc:`BusyError` or :exc:`LockedError` if\n" \
"unable to lock the source database.  You can catch those and try\n" \
"again.\n" \
"\n" \
":returns: True if this copied the last remaining outstanding pages, else False.  This is the same value as :attr:`~Backup.done`\n" \
"\n" \
"Calls: `sqlite3_backup_step <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupstep>`__\n" 

#define Backup_step_KWNAMES "npages"
#define Backup_step_USAGE "Backup.step(npages: int = -1) -> bool"

#define Backup_step_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(npages), int)); \
  assert(npages == (-1)); \
} while(0)


#define  Blob_class_DOC "This object is created by :meth:`Connection.blob_open` and provides\n" \
"access to a blob in the database.  It behaves like a Python file.\n" \
"It wraps a `sqlite3_blob\n" \
"<https://sqlite.org/c3ref/blob.html>`_.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You cannot change the size of a blob using this object. You should\n" \
"  create it with the correct size in advance either by using\n" \
"  :class:`zeroblob` or the `zeroblob()\n" \
"  <https://sqlite.org/lang_corefunc.html>`_ function.\n" \
"\n" \
"See the :ref:`example <example_blob_io>`.\n" 

#define  Blob_close_DOC "Blob.close(force: bool = False) -> None\n\n" \
"Closes the blob.  Note that even if an error occurs the blob is\n" \
"still closed.\n" \
"\n" \
".. note::\n" \
"\n" \
"   In some cases errors that technically occurred in the\n" \
"   :meth:`~Blob.read` and :meth:`~Blob.write` routines may not be\n" \
"   reported until close is called.  Similarly errors that occurred\n" \
"   in those methods (eg calling :meth:`~Blob.write` on a read-only\n" \
"   blob) may also be re-reported in :meth:`~Blob.close`.  (This\n" \
"   behaviour is what the underlying SQLite APIs do - it is not APSW\n" \
"   doing it.)\n" \
"\n" \
"It is okay to call :meth:`~Blob.close` multiple times.\n" \
"\n" \
":param force: Ignores any errors during close.\n" \
"\n" \
"Calls: `sqlite3_blob_close <https://sqlite.org/c3ref/blob_close.html>`__\n" 

#define Blob_close_KWNAMES "force"
#define Blob_close_USAGE "Blob.close(force: bool = False) -> None"

#define Blob_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Blob_enter_DOC "Blob.__enter__() -> Blob\n\n" \
"You can use a blob as a `context manager\n" \
"<https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* statement,\n" \
"the blob is always :meth:`closed <Blob.close>` on exit from the block, even if an\n" \
"exception occurred in the block.\n" \
"\n" \
"For example::\n" \
"\n" \
"  with connection.blob_open() as blob:\n" \
"      blob.write(\"...\")\n" \
"      res=blob.read(1024)\n" 

#define  Blob_exit_DOC "Blob.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~Blob.__enter__`.  Any exception that happened in the\n" \
"*with* block is raised after closing the blob.\n" 

#define  Blob_length_DOC "Blob.length() -> int\n\n" \
"Returns the size of the blob in bytes.\n" \
"\n" \
"Calls: `sqlite3_blob_bytes <https://sqlite.org/c3ref/blob_bytes.html>`__\n" 

#define  Blob_read_DOC "Blob.read(length: int = -1) -> bytes\n\n" \
"Reads amount of data requested, or till end of file, whichever is\n" \
"earlier. Attempting to read beyond the end of the blob returns an\n" \
"empty bytes in the same manner as end of file on normal file\n" \
"objects.  Negative numbers read all remaining data.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_read_KWNAMES "length"
#define Blob_read_USAGE "Blob.read(length: int = -1) -> bytes"

#define Blob_read_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(length), int)); \
  assert(length == (-1)); \
} while(0)


#define  Blob_read_into_DOC "Blob.read_into(buffer: bytearray |  array.array[Any] | memoryview, offset: int = 0, length: int = -1) -> None\n\n" \
"Reads from the blob into a buffer you have supplied.  This method is\n" \
"useful if you already have a buffer like object that data is being\n" \
"assembled in, and avoids allocating results in :meth:`Blob.read` and\n" \
"then copying into buffer.\n" \
"\n" \
":param buffer: A writable buffer like object.\n" \
"               There is a :class:`bytearray` type that is very useful.\n" \
"               :mod:`Arrays <array>` also work.\n" \
"\n" \
":param offset: The position to start writing into the buffer\n" \
"               defaulting to the beginning.\n" \
"\n" \
":param length: How much of the blob to read.  The default is the\n" \
"               remaining space left in the buffer.  Note that if\n" \
"               there is more space available than blob left then you\n" \
"               will get a *ValueError* exception.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_read_into_KWNAMES "buffer", "offset", "length"
#define Blob_read_into_USAGE "Blob.read_into(buffer: bytearray |  array.array[Any] | memoryview, offset: int = 0, length: int = -1) -> None"

#define Blob_read_into_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(buffer), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
  assert(offset == 0L); \
  assert(__builtin_types_compatible_p(typeof(length), long long)); \
  assert(length == -1L); \
} while(0)


#define Blob_read_into_OLDNAME "readinto"
#define Blob_read_into_OLDDOC Blob_read_into_USAGE "\n(Old less clear name readinto)"

#define  Blob_reopen_DOC "Blob.reopen(rowid: int) -> None\n\n" \
"Change this blob object to point to a different row.  It can be\n" \
"faster than closing an existing blob an opening a new one.\n" \
"\n" \
"Calls: `sqlite3_blob_reopen <https://sqlite.org/c3ref/blob_reopen.html>`__\n" 

#define Blob_reopen_KWNAMES "rowid"
#define Blob_reopen_USAGE "Blob.reopen(rowid: int) -> None"

#define Blob_reopen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Blob_seek_DOC "Blob.seek(offset: int, whence: int = 0) -> None\n\n" \
"Changes current position to *offset* biased by *whence*.\n" \
"\n" \
":param offset: New position to seek to.  Can be positive or negative number.\n" \
":param whence: Use 0 if *offset* is relative to the beginning of the blob,\n" \
"               1 if *offset* is relative to the current position,\n" \
"               and 2 if *offset* is relative to the end of the blob.\n" \
":raises ValueError: If the resulting offset is before the beginning (less than zero) or beyond the end of the blob.\n" 

#define Blob_seek_KWNAMES "offset", "whence"
#define Blob_seek_USAGE "Blob.seek(offset: int, whence: int = 0) -> None"

#define Blob_seek_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(offset), int)); \
  assert(__builtin_types_compatible_p(typeof(whence), int)); \
  assert(whence == (0)); \
} while(0)


#define  Blob_tell_DOC "Blob.tell() -> int\n\n" \
"Returns the current offset.\n" 

#define  Blob_write_DOC "Blob.write(data: Buffer) -> None\n\n" \
"Writes the data to the blob.\n" \
"\n" \
":param data: Buffer to write\n" \
"\n" \
":raises TypeError: Wrong data type\n" \
"\n" \
":raises ValueError: If the data would go beyond the end of the blob.\n" \
"    You cannot increase the size of a blob by writing beyond the end.\n" \
"    You need to use :class:`zeroblob` to set the desired size first when\n" \
"    inserting the blob.\n" \
"\n" \
"Calls: `sqlite3_blob_write <https://sqlite.org/c3ref/blob_write.html>`__\n" 

#define Blob_write_KWNAMES "data"
#define Blob_write_USAGE "Blob.write(data: Buffer) -> None"

#define Blob_write_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), PyObject *)); \
} while(0)


#define  ChangesetBuilder_add_DOC "ChangesetBuilder.add(changeset: ChangesetInput) -> None\n\n" \
":param changeset: The changeset as the bytes, or a stream\n" \
"\n" \
"Adds the changeset to the builder\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3changegroup_add <https://sqlite.org/session/sqlite3changegroup_add.html>`__\n" \
"  * `sqlite3changegroup_add_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define ChangesetBuilder_add_KWNAMES "changeset"
#define ChangesetBuilder_add_USAGE "ChangesetBuilder.add(changeset: ChangesetInput) -> None"

#define ChangesetBuilder_add_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
} while(0)


#define  ChangesetBuilder_add_change_DOC "ChangesetBuilder.add_change(change: TableChange) -> None\n\n" \
":param change: An individual change to add.\n" \
"\n" \
"You can obtain :class:`TableChange` from :meth:`Changeset.iter` or from the conflict callback\n" \
"of :meth:`Changeset.apply`.\n" \
"\n" \
"Calls: `sqlite3changegroup_add_change <https://sqlite.org/session/sqlite3changegroup_add_change.html>`__\n" 

#define ChangesetBuilder_add_change_KWNAMES "change"
#define ChangesetBuilder_add_change_USAGE "ChangesetBuilder.add_change(change: TableChange) -> None"

#define ChangesetBuilder_add_change_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(change), APSWTableChange *)); \
} while(0)


#define  ChangesetBuilder_class_DOC "This object wraps a `sqlite3_changegroup <https://sqlite.org/session/changegroup.html>`__\n" \
"letting you concatenate changesets and individual :class:`TableChange` into one larger\n" \
"changeset.\n" 

#define  ChangesetBuilder_close_DOC "ChangesetBuilder.close() -> None\n\n" \
"Releases the builder\n" \
"\n" \
"Calls: `sqlite3changegroup_delete <https://sqlite.org/session/sqlite3changegroup_delete.html>`__\n" 

#define ChangesetBuilder_close_KWNAMES NULL
#define ChangesetBuilder_close_USAGE "ChangesetBuilder.close() -> None"

#define ChangesetBuilder_close_CHECK do { \
} while(0)


#define  ChangesetBuilder_init_DOC "ChangesetBuilder.__init__()\n\n" \
"Creates a new empty builder.\n" \
"\n" \
"Calls: `sqlite3changegroup_new <https://sqlite.org/session/sqlite3changegroup_new.html>`__\n" 

#define ChangesetBuilder_init_KWNAMES NULL
#define ChangesetBuilder_init_USAGE "ChangesetBuilder.__init__()"

#define ChangesetBuilder_init_CHECK do { \
} while(0)


#define  ChangesetBuilder_output_DOC "ChangesetBuilder.output() -> bytes\n\n" \
"Produces a changeset of what was built so far\n" \
"\n" \
"Calls: `sqlite3changegroup_output <https://sqlite.org/session/sqlite3changegroup_output.html>`__\n" 

#define ChangesetBuilder_output_KWNAMES NULL
#define ChangesetBuilder_output_USAGE "ChangesetBuilder.output() -> bytes"

#define ChangesetBuilder_output_CHECK do { \
} while(0)


#define  ChangesetBuilder_output_stream_DOC "ChangesetBuilder.output_stream(output: SessionStreamOutput) -> None\n\n" \
"Produces a streaming changeset of what was built so far\n" \
"\n" \
"Calls: `sqlite3changegroup_output_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define ChangesetBuilder_output_stream_KWNAMES "output"
#define ChangesetBuilder_output_stream_USAGE "ChangesetBuilder.output_stream(output: SessionStreamOutput) -> None"

#define ChangesetBuilder_output_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  ChangesetBuilder_schema_DOC "ChangesetBuilder.schema(db: Connection, schema: str) -> None\n\n" \
"Ensures the changesets comply with the tables in the database\n" \
"\n" \
":param db: Connection to consult\n" \
":param schema: `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"You will get :exc:`MisuseError` if changes have already been added, or this method has\n" \
"already been called.\n" \
"\n" \
"Calls: `sqlite3changegroup_schema <https://sqlite.org/session/sqlite3changegroup_schema.html>`__\n" 

#define ChangesetBuilder_schema_KWNAMES "db", "schema"
#define ChangesetBuilder_schema_USAGE "ChangesetBuilder.schema(db: Connection, schema: str) -> None"

#define ChangesetBuilder_schema_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(db), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
} while(0)


#define  Changeset_apply_DOC "Changeset.apply(changeset: ChangesetInput, db: Connection, *, filter: Optional[Callable[[str], bool]] = None, conflict: Optional[Callable[[int,TableChange], int]] = None, flags: int = 0, rebase: bool = False) -> bytes | None\n\n" \
"Applies a changeset to a database.\n" \
"\n" \
":param source: The changeset either as the bytes, or a stream\n" \
":param db: The connection to make the change on\n" \
":param filter: Callback to determine if changes to a table are done\n" \
":param conflict: Callback to handle a change that cannot be applied\n" \
":param flags: `v2 API flags <https://www.sqlite.org/session/c_changesetapply_fknoaction.html>`__.\n" \
":param rebase: If ``True`` then return :class:`rebase <Rebaser>` information, else :class:`None`.\n" \
"\n" \
"Filter\n" \
"------\n" \
"\n" \
"Callback called with a table name, once per table that has a change.  It should return ``True``\n" \
"if changes to that table should be applied, or ``False`` to ignore them.  If not supplied then\n" \
"all tables have changes applied.\n" \
"\n" \
"Conflict\n" \
"--------\n" \
"\n" \
"When a change cannot be applied the conflict handler determines what\n" \
"to do.  It is called with a `conflict reason\n" \
"<https://www.sqlite.org/session/c_changeset_conflict.html>`__ as the\n" \
"first parameter, and a :class:`TableChange` as the second.  Possible\n" \
"conflicts are `described here\n" \
"<https://sqlite.org/sessionintro.html#conflicts>`__.\n" \
"\n" \
"It should return the `action to take <https://www.sqlite.org/session/c_changeset_abort.html>`__.\n" \
"\n" \
"If not supplied or on error, ``SQLITE_CHANGESET_ABORT`` is returned.\n" \
"\n" \
"See the :ref:`example <example_applying>`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3changeset_apply_v2 <https://sqlite.org/session/sqlite3changeset_apply.html>`__\n" \
"  * `sqlite3changeset_apply_v2_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Changeset_apply_KWNAMES "changeset", "db", "filter", "conflict", "flags", "rebase"
#define Changeset_apply_USAGE "Changeset.apply(changeset: ChangesetInput, db: Connection, *, filter: Optional[Callable[[str], bool]] = None, conflict: Optional[Callable[[int,TableChange], int]] = None, flags: int = 0, rebase: bool = False) -> bytes | None"

#define Changeset_apply_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(db), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(filter), PyObject *)); \
  assert(filter == NULL); \
  assert(__builtin_types_compatible_p(typeof(conflict), PyObject *)); \
  assert(conflict == NULL); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
  assert(__builtin_types_compatible_p(typeof(rebase), int)); \
  assert(rebase == 0); \
} while(0)


#define  Changeset_class_DOC "Provides changeset (including patchset) related methods.  Note that\n" \
"all methods are static (belong to the class).  There is no Changeset\n" \
"object.   On input Changesets can be a :class:`collections.abc.Buffer`\n" \
"(anything that resembles a sequence of bytes), or\n" \
":class:`SessionStreamInput` which provides the bytes in chunks from a\n" \
"callback.\n" \
"\n" \
"Output is bytes, or :class:`SessionStreamOutput` (chunks in a callback).\n" \
"\n" \
"The streaming versions are useful when you are concerned about memory\n" \
"usage, or where changesets are larger than 2GB (the SQLite limit).\n" 

#define  Changeset_concat_DOC "Changeset.concat(A: Buffer, B: Buffer) -> bytes\n\n" \
"Returns combined changesets\n" \
"\n" \
"Calls: `sqlite3changeset_concat <https://sqlite.org/session/sqlite3changeset_concat.html>`__\n" 

#define Changeset_concat_KWNAMES "A", "B"
#define Changeset_concat_USAGE "Changeset.concat(A: Buffer, B: Buffer) -> bytes"

#define Changeset_concat_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(A), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(B), PyObject *)); \
} while(0)


#define  Changeset_concat_stream_DOC "Changeset.concat_stream(A: SessionStreamInput, B: SessionStreamInput, output: SessionStreamOutput) -> None\n\n" \
"Streaming concatenate two changesets\n" \
"\n" \
"Calls: `sqlite3changeset_concat_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Changeset_concat_stream_KWNAMES "A", "B", "output"
#define Changeset_concat_stream_USAGE "Changeset.concat_stream(A: SessionStreamInput, B: SessionStreamInput, output: SessionStreamOutput) -> None"

#define Changeset_concat_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(A), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(B), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  Changeset_invert_DOC "Changeset.invert(changeset: Buffer) -> bytes\n\n" \
"Produces a changeset that reverses the effect of\n" \
"the supplied changeset.\n" \
"\n" \
"Calls: `sqlite3changeset_invert <https://sqlite.org/session/sqlite3changeset_invert.html>`__\n" 

#define Changeset_invert_KWNAMES "changeset"
#define Changeset_invert_USAGE "Changeset.invert(changeset: Buffer) -> bytes"

#define Changeset_invert_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
} while(0)


#define  Changeset_invert_stream_DOC "Changeset.invert_stream(changeset: SessionStreamInput, output: SessionStreamOutput) -> None\n\n" \
"Streaming reverses the effect of the supplied changeset.\n" \
"\n" \
"Calls: `sqlite3changeset_invert_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Changeset_invert_stream_KWNAMES "changeset", "output"
#define Changeset_invert_stream_USAGE "Changeset.invert_stream(changeset: SessionStreamInput, output: SessionStreamOutput) -> None"

#define Changeset_invert_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  Changeset_iter_DOC "Changeset.iter(changeset: ChangesetInput, *, flags: int = 0) -> Iterator[TableChange]\n\n" \
"Provides an iterator over a changeset.  You can supply the changeset as\n" \
" the bytes, or streamed via a callable.\n" \
"\n" \
" If flags is non-zero them the ``v2`` API is used (marked as experimental)\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3changeset_start <https://sqlite.org/session/sqlite3changeset_start.html>`__\n" \
"  * `sqlite3changeset_start_v2 <https://sqlite.org/session/sqlite3changeset_start.html>`__\n" \
"  * `sqlite3changeset_start_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" \
"  * `sqlite3changeset_start_v2_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Changeset_iter_KWNAMES "changeset", "flags"
#define Changeset_iter_USAGE "Changeset.iter(changeset: ChangesetInput, *, flags: int = 0) -> Iterator[TableChange]"

#define Changeset_iter_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define  Connection_authorizer_DOC ":type: Optional[Authorizer]\n" \
"\n" \
"While `preparing <https://sqlite.org/c3ref/prepare.html>`_\n" \
"statements, SQLite will call any defined authorizer to see if a\n" \
"particular action is ok to be part of the statement.\n" \
"\n" \
"Typical usage would be if you are running user supplied SQL and want\n" \
"to prevent harmful operations.  You should also\n" \
"set the :class:`statementcachesize <Connection>` to zero.\n" \
"\n" \
"The authorizer callback has 5 parameters:\n" \
"\n" \
"  * An `operation code <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 3rd) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 4th) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string name of the database (or None)\n" \
"  * Name of the innermost trigger or view doing the access (or None)\n" \
"\n" \
"The authorizer callback should return one of *SQLITE_OK*,\n" \
"*SQLITE_DENY* or *SQLITE_IGNORE*.\n" \
"(*SQLITE_DENY* is returned if there is an error in your\n" \
"Python code).\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_authorizer>`\n" \
"  * :ref:`statementcache`\n" \
"\n" \
"Calls: `sqlite3_set_authorizer <https://sqlite.org/c3ref/set_authorizer.html>`__\n" 

#define  Connection_autovacuum_pages_DOC "Connection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None\n\n" \
"Calls `callable` to find out how many pages to autovacuum.  The callback has 4 parameters:\n" \
"\n" \
"* Database name: str. `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"* Database pages: int (how many pages make up the database now)\n" \
"* Free pages: int (how many pages could be freed)\n" \
"* Page size: int (page size in bytes)\n" \
"\n" \
"Return how many pages should be freed.  Values less than zero or more than the free pages are\n" \
"treated as zero or free page count.  On error zero is returned.\n" \
"\n" \
".. warning:: READ THE NOTE IN THE SQLITE DOCUMENTATION.\n" \
"\n" \
"  Calling back into SQLite can result in crashes, corrupt\n" \
"  databases, or worse.\n" \
"\n" \
"Calls: `sqlite3_autovacuum_pages <https://sqlite.org/c3ref/autovacuum_pages.html>`__\n" 

#define Connection_autovacuum_pages_KWNAMES "callable"
#define Connection_autovacuum_pages_USAGE "Connection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None"

#define Connection_autovacuum_pages_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_backup_DOC "Connection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup\n\n" \
"Opens a :ref:`backup object <Backup>`.  All data will be copied from source\n" \
"database to this database.\n" \
"\n" \
":param databasename: Name of the database. `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
":param sourceconnection: The :class:`Connection` to copy a database from.\n" \
":param sourcedatabasename: Name of the database in the source (eg ``main``).\n" \
"\n" \
":rtype: :class:`Backup`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :doc:`Backup reference <backup>`\n" \
"  * :ref:`Backup example <example_backup>`\n" \
"\n" \
"Calls: `sqlite3_backup_init <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit>`__\n" 

#define Connection_backup_KWNAMES "databasename", "sourceconnection", "sourcedatabasename"
#define Connection_backup_USAGE "Connection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup"

#define Connection_backup_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(databasename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(sourceconnection), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(sourcedatabasename), const char *)); \
} while(0)


#define  Connection_blob_open_DOC "Connection.blob_open(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob\n\n" \
"Opens a blob for :ref:`incremental I/O <blobio>`.\n" \
"\n" \
":param database: Name of the database.  `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__.\n" \
":param table: The name of the table\n" \
":param column: The name of the column\n" \
":param rowid: The id that uniquely identifies the row.\n" \
":param writeable: If True then you can read and write the blob.  If False then you can only read it.\n" \
"\n" \
":rtype: :class:`Blob`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Blob I/O example <example_blob_io>`\n" \
"  * `SQLite row ids <https://sqlite.org/autoinc.html>`_\n" \
"\n" \
"Calls: `sqlite3_blob_open <https://sqlite.org/c3ref/blob_open.html>`__\n" 

#define Connection_blob_open_KWNAMES "database", "table", "column", "rowid", "writeable"
#define Connection_blob_open_USAGE "Connection.blob_open(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob"

#define Connection_blob_open_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(database), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table), const char *)); \
  assert(__builtin_types_compatible_p(typeof(column), const char *)); \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
  assert(__builtin_types_compatible_p(typeof(writeable), int)); \
} while(0)


#define Connection_blob_open_OLDNAME "blobopen"
#define Connection_blob_open_OLDDOC Connection_blob_open_USAGE "\n(Old less clear name blobopen)"

#define  Connection_cache_flush_DOC "Connection.cache_flush() -> None\n\n" \
"Flushes caches to disk mid-transaction.\n" \
"\n" \
"Calls: `sqlite3_db_cacheflush <https://sqlite.org/c3ref/db_cacheflush.html>`__\n" 

#define Connection_cache_flush_OLDNAME "cacheflush"
#define Connection_cache_flush_USAGE "Connection.cache_flush() -> None"
#define Connection_cache_flush_OLDDOC Connection_cache_flush_USAGE "\n(Old less clear name cacheflush)"

#define  Connection_cache_stats_DOC "Connection.cache_stats(include_entries: bool = False) -> dict[str, int]\n\n" \
"Returns information about the statement cache as dict.\n" \
"\n" \
".. note::\n" \
"\n" \
"  Calling execute with \"select a; select b; insert into c ...\" will\n" \
"  result in 3 cache entries corresponding to each of the 3 queries\n" \
"  present.\n" \
"\n" \
"The returned dictionary has the following information.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Explanation\n" \
"  * - size\n" \
"    - Maximum number of entries in the cache\n" \
"  * - evictions\n" \
"    - How many entries were removed (expired) to make space for a newer\n" \
"      entry\n" \
"  * - no_cache\n" \
"    - Queries that had can_cache parameter set to False\n" \
"  * - hits\n" \
"    - A match was found in the cache\n" \
"  * - misses\n" \
"    - No match was found in the cache, or the cache couldn't be used\n" \
"  * - no_vdbe\n" \
"    - The statement was empty (eg a comment) or SQLite took action\n" \
"      during parsing (eg some pragmas).  These are not cached and also\n" \
"      included in the misses count\n" \
"  * - too_big\n" \
"    - UTF8 query size was larger than considered for caching.  These are also included\n" \
"      in the misses count.\n" \
"  * - max_cacheable_bytes\n" \
"    - Maximum size of query (in bytes of utf8) that will be considered for caching\n" \
"  * - entries\n" \
"    - (Only present if `include_entries` is True) A list of the cache entries\n" \
"\n" \
"If `entries` is present, then each list entry is a dict with the following information.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Explanation\n" \
"  * - query\n" \
"    - Text of the query itself (first statement only)\n" \
"  * - prepare_flags\n" \
"    - Flags passed to `sqlite3_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"      for this query\n" \
"  * - explain\n" \
"    - The value passed to `sqlite3_stmt_explain <https://sqlite.org/c3ref/stmt_explain.html>`__\n" \
"      if >= 0\n" \
"  * - uses\n" \
"    - How many times this entry has been (re)used\n" \
"  * - has_more\n" \
"    - Boolean indicating if there was more query text than\n" \
"      the first statement\n" 

#define Connection_cache_stats_KWNAMES "include_entries"
#define Connection_cache_stats_USAGE "Connection.cache_stats(include_entries: bool = False) -> dict[str, int]"

#define Connection_cache_stats_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(include_entries), int)); \
  assert(include_entries == 0); \
} while(0)


#define  Connection_changes_DOC "Connection.changes() -> int\n\n" \
"Returns the number of database rows that were changed (or inserted\n" \
"or deleted) by the most recently completed INSERT, UPDATE, or DELETE\n" \
"statement.\n" \
"\n" \
"Calls: `sqlite3_changes64 <https://sqlite.org/c3ref/changes.html>`__\n" 

#define  Connection_class_DOC "This object wraps a `sqlite3 pointer\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_.\n" 

#define  Connection_close_DOC "Connection.close(force: bool = False) -> None\n\n" \
"Closes the database.  If there are any outstanding :class:`cursors\n" \
"<Cursor>`, :class:`blobs <Blob>` or :class:`backups <Backup>` then\n" \
"they are closed too.  It is normally not necessary to call this\n" \
"method as the database is automatically closed when there are no\n" \
"more references.  It is ok to call the method multiple times.\n" \
"\n" \
"If your user defined functions or collations have direct or indirect\n" \
"references to the Connection then it won't be automatically garbage\n" \
"collected because of circular referencing that can't be\n" \
"automatically broken.  Calling *close* will free all those objects\n" \
"and what they reference.\n" \
"\n" \
"SQLite is designed to survive power failures at even the most\n" \
"awkward moments.  Consequently it doesn't matter if it is closed\n" \
"when the process is exited, or even if the exit is graceful or\n" \
"abrupt.  In the worst case of having a transaction in progress, that\n" \
"transaction will be rolled back by the next program to open the\n" \
"database, reverting the database to a know good state.\n" \
"\n" \
"If *force* is *True* then any exceptions are ignored.\n" \
"\n" \
"Calls: `sqlite3_close <https://sqlite.org/c3ref/close.html>`__\n" 

#define Connection_close_KWNAMES "force"
#define Connection_close_USAGE "Connection.close(force: bool = False) -> None"

#define Connection_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Connection_collation_needed_DOC "Connection.collation_needed(callable: Optional[Callable[[Connection, str], None]]) -> None\n\n" \
"*callable* will be called if a statement requires a `collation\n" \
"<https://en.wikipedia.org/wiki/Collation>`_ that hasn't been\n" \
"registered. Your callable will be passed two parameters. The first\n" \
"is the connection object. The second is the name of the\n" \
"collation. If you have the collation code available then call\n" \
":meth:`Connection.create_collation`.\n" \
"\n" \
"This is useful for creating collations on demand.  For example you\n" \
"may include the `locale <https://en.wikipedia.org/wiki/Locale>`_ in\n" \
"the collation name, but since there are thousands of locales in\n" \
"popular use it would not be useful to :meth:`prereigster\n" \
"<Connection.create_collation>` them all.  Using\n" \
":meth:`~Connection.collation_needed` tells you when you need to\n" \
"register them.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.create_collation`\n" \
"\n" \
"Calls: `sqlite3_collation_needed <https://sqlite.org/c3ref/collation_needed.html>`__\n" 

#define Connection_collation_needed_KWNAMES "callable"
#define Connection_collation_needed_USAGE "Connection.collation_needed(callable: Optional[Callable[[Connection, str], None]]) -> None"

#define Connection_collation_needed_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_collation_needed_OLDNAME "collationneeded"
#define Connection_collation_needed_OLDDOC Connection_collation_needed_USAGE "\n(Old less clear name collationneeded)"

#define  Connection_column_metadata_DOC "Connection.column_metadata(dbname: Optional[str], table_name: str, column_name: str) -> tuple[str, str, bool, bool, bool]\n\n" \
"`dbname` is `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__, or None to search\n" \
"all databases.\n" \
"\n" \
"The returned :class:`tuple` has these fields:\n" \
"\n" \
"0: str - declared data type\n" \
"\n" \
"1: str - name of default collation sequence\n" \
"\n" \
"2: bool - True if not null constraint\n" \
"\n" \
"3: bool - True if part of primary key\n" \
"\n" \
"4: bool - True if column is `autoincrement <https://www.sqlite.org/autoinc.html>`__\n" \
"\n" \
"Calls: `sqlite3_table_column_metadata <https://sqlite.org/c3ref/table_column_metadata.html>`__\n" 

#define Connection_column_metadata_KWNAMES "dbname", "table_name", "column_name"
#define Connection_column_metadata_USAGE "Connection.column_metadata(dbname: Optional[str], table_name: str, column_name: str) -> tuple[str, str, bool, bool, bool]"

#define Connection_column_metadata_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table_name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(column_name), const char *)); \
} while(0)


#define  Connection_config_DOC "Connection.config(op: int, *args: int) -> int\n\n" \
":param op: A `configuration operation\n" \
"  <https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html>`__\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"This is how to get the fkey setting::\n" \
"\n" \
"  val = db.config(apsw.SQLITE_DBCONFIG_ENABLE_FKEY, -1)\n" \
"\n" \
"A parameter of zero would turn it off, 1 turns on, and negative\n" \
"leaves unaltered.  The effective value is always returned.\n" \
"\n" \
"Calls: `sqlite3_db_config <https://sqlite.org/c3ref/db_config.html>`__\n" 

#define  Connection_create_aggregate_function_DOC "Connection.create_aggregate_function(name: str, factory: Optional[AggregateFactory], numargs: int = -1, *, flags: int = 0) -> None\n\n" \
"Registers an aggregate function.  Aggregate functions operate on all\n" \
"the relevant rows such as counting how many there are.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param factory: The function that will be called.  Use None to delete the function.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param flags: `Function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
"When a query starts, the *factory* will be called.  It can return an object\n" \
"with a *step* function called for each matching row, and a *final* function\n" \
"to provide the final value.\n" \
"\n" \
"Alternatively a non-class approach can return a tuple of 3 items:\n" \
"\n" \
"  a context object\n" \
"     This can be of any type\n" \
"\n" \
"  a step function\n" \
"     This function is called once for each row.  The first parameter\n" \
"     will be the context object and the remaining parameters will be\n" \
"     from the SQL statement.  Any value returned will be ignored.\n" \
"\n" \
"  a final function\n" \
"     This function is called at the very end with the context object\n" \
"     as a parameter.  The value returned is set as the return for\n" \
"     the function. The final function is always called even if an\n" \
"     exception was raised by the step function. This allows you to\n" \
"     ensure any resources are cleaned up.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  callables and *numargs*.  See\n" \
"  :meth:`~Connection.create_scalar_function` for an example.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_aggregate>`\n" \
"   * :meth:`~Connection.create_scalar_function`\n" \
"   * :meth:`~Connection.create_window_function`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_create_aggregate_function_KWNAMES "name", "factory", "numargs", "flags"
#define Connection_create_aggregate_function_USAGE "Connection.create_aggregate_function(name: str, factory: Optional[AggregateFactory], numargs: int = -1, *, flags: int = 0) -> None"

#define Connection_create_aggregate_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(factory), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define Connection_create_aggregate_function_OLDNAME "createaggregatefunction"
#define Connection_create_aggregate_function_OLDDOC Connection_create_aggregate_function_USAGE "\n(Old less clear name createaggregatefunction)"

#define  Connection_create_collation_DOC "Connection.create_collation(name: str, callback: Optional[Callable[[str, str], int]]) -> None\n\n" \
"You can control how SQLite sorts (termed `collation\n" \
"<https://en.wikipedia.org/wiki/Collation>`_) when giving the\n" \
"``COLLATE`` term to a `SELECT\n" \
"<https://sqlite.org/lang_select.html>`_.  For example your\n" \
"collation could take into account locale or do numeric sorting.\n" \
"\n" \
"The *callback* will be called with two items.  It should return -1\n" \
"if the first is less then the second, 0 if they are equal, and 1 if\n" \
"first is greater::\n" \
"\n" \
"   def mycollation(first: str, two: str) -> int:\n" \
"       if first < second:\n" \
"           return -1\n" \
"       if first == second:\n" \
"           return 0\n" \
"       if first > second:\n" \
"           return 1\n" \
"\n" \
"Passing None as the callback will unregister the collation.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_collation>`\n" \
"  * :meth:`Connection.collation_needed`\n" \
"\n" \
"Calls: `sqlite3_create_collation_v2 <https://sqlite.org/c3ref/create_collation.html>`__\n" 

#define Connection_create_collation_KWNAMES "name", "callback"
#define Connection_create_collation_USAGE "Connection.create_collation(name: str, callback: Optional[Callable[[str, str], int]]) -> None"

#define Connection_create_collation_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
} while(0)


#define Connection_create_collation_OLDNAME "createcollation"
#define Connection_create_collation_OLDDOC Connection_create_collation_USAGE "\n(Old less clear name createcollation)"

#define  Connection_create_module_DOC "Connection.create_module(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None\n\n" \
"Registers a virtual table, or drops it if *datasource* is *None*.\n" \
"See :ref:`virtualtables` for details.\n" \
"\n" \
":param name: Module name (CREATE VIRTUAL TABLE table_name USING module_name...)\n" \
":param datasource: Provides :class:`VTModule` methods\n" \
":param use_bestindex_object: If True then BestIndexObject is used, else BestIndex\n" \
":param use_no_change: Turn on understanding :meth:`VTCursor.ColumnNoChange` and using :attr:`apsw.no_change` to reduce :meth:`VTTable.UpdateChangeRow` work\n" \
":param iVersion: iVersion field in `sqlite3_module <https://www.sqlite.org/c3ref/module.html>`__\n" \
":param eponymous: Configures module to be `eponymous <https://www.sqlite.org/vtab.html#eponymous_virtual_tables>`__\n" \
":param eponymous_only: Configures module to be `eponymous only <https://www.sqlite.org/vtab.html#eponymous_only_virtual_tables>`__\n" \
":param read_only: Leaves `sqlite3_module <https://www.sqlite.org/c3ref/module.html>`__ methods that involve writing and transactions as NULL\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_virtual_tables>`\n" \
"\n" \
"Calls: `sqlite3_create_module_v2 <https://sqlite.org/c3ref/create_module.html>`__\n" 

#define Connection_create_module_KWNAMES "name", "datasource", "use_bestindex_object", "use_no_change", "iVersion", "eponymous", "eponymous_only", "read_only"
#define Connection_create_module_USAGE "Connection.create_module(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None"

#define Connection_create_module_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(datasource), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(use_bestindex_object), int)); \
  assert(use_bestindex_object == 0); \
  assert(__builtin_types_compatible_p(typeof(use_no_change), int)); \
  assert(use_no_change == 0); \
  assert(__builtin_types_compatible_p(typeof(iVersion), int)); \
  assert(iVersion == (1)); \
  assert(__builtin_types_compatible_p(typeof(eponymous), int)); \
  assert(eponymous == 0); \
  assert(__builtin_types_compatible_p(typeof(eponymous_only), int)); \
  assert(eponymous_only == 0); \
  assert(__builtin_types_compatible_p(typeof(read_only), int)); \
  assert(read_only == 0); \
} while(0)


#define Connection_create_module_OLDNAME "createmodule"
#define Connection_create_module_OLDDOC Connection_create_module_USAGE "\n(Old less clear name createmodule)"

#define  Connection_create_scalar_function_DOC "Connection.create_scalar_function(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None\n\n" \
"Registers a scalar function.  Scalar functions operate on one set of parameters once.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param callable: The function that will be called.  Use None to unregister.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param deterministic: When True this means the function always\n" \
"         returns the same result for the same input arguments.\n" \
"         SQLite's query planner can perform additional optimisations\n" \
"         for deterministic functions.  For example a random()\n" \
"         function is not deterministic while one that returns the\n" \
"         length of a string is.\n" \
":param flags: Additional `function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  *callable* and *numargs*.  For example::\n" \
"\n" \
"    connection.create_scalar_function(\"toip\", ipv4convert, 4)\n" \
"    connection.create_scalar_function(\"toip\", ipv6convert, 16)\n" \
"    connection.create_scalar_function(\"toip\", strconvert, -1)\n" \
"\n" \
"  The one with the correct *numargs* will be called and only if that\n" \
"  doesn't exist then the one with negative *numargs* will be called.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_scalar>`\n" \
"   * :meth:`~Connection.create_aggregate_function`\n" \
"   * :meth:`~Connection.create_window_function`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_create_scalar_function_KWNAMES "name", "callable", "numargs", "deterministic", "flags"
#define Connection_create_scalar_function_USAGE "Connection.create_scalar_function(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None"

#define Connection_create_scalar_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(deterministic), int)); \
  assert(deterministic == 0); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define Connection_create_scalar_function_OLDNAME "createscalarfunction"
#define Connection_create_scalar_function_OLDDOC Connection_create_scalar_function_USAGE "\n(Old less clear name createscalarfunction)"

#define  Connection_create_window_function_DOC "Connection.create_window_function(name:str, factory: Optional[WindowFactory], numargs: int =-1, *, flags: int = 0) -> None\n\n" \
"Registers a `window function\n" \
"<https://sqlite.org/windowfunctions.html#user_defined_aggregate_window_functions>`__\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param factory: Called to start a new window.  Use None to delete the function.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param flags: `Function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
"You need to provide callbacks for the ``step``, ``final``, ``value``\n" \
"and ``inverse`` methods.  This can be done by having `factory` as a\n" \
"class, returning an instance with the corresponding method names, or by having `factory`\n" \
"return a sequence of a first parameter, and then each of the 4\n" \
"functions.\n" \
"\n" \
"**Debugging note** SQlite always calls the ``final`` method to allow\n" \
"for cleanup.  If you have an exception in one of the other methods, then\n" \
"``final`` will also be called, and you may see both methods in\n" \
"tracebacks.\n" \
"\n" \
".. seealso::\n" \
"\n" \
" * :ref:`Example <example_window>`\n" \
" * :meth:`~Connection.create_scalar_function`\n" \
" * :meth:`~Connection.create_aggregate_function`\n" \
"\n" \
"Calls: `sqlite3_create_window_function <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_create_window_function_KWNAMES "name", "factory", "numargs", "flags"
#define Connection_create_window_function_USAGE "Connection.create_window_function(name:str, factory: Optional[WindowFactory], numargs: int =-1, *, flags: int = 0) -> None"

#define Connection_create_window_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(factory), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define  Connection_cursor_DOC "Connection.cursor() -> Cursor\n\n" \
"Creates a new :class:`Cursor` object on this database.\n" \
"\n" \
":rtype: :class:`Cursor`\n" 

#define  Connection_cursor_factory_DOC ":type: Callable[[Connection], Any]\n" \
"\n" \
"Defaults to :class:`Cursor`\n" \
"\n" \
"Called with a :class:`Connection` as the only parameter when a cursor\n" \
"is needed such as by the :meth:`cursor` method, or\n" \
":meth:`Connection.execute`.\n" \
"\n" \
"Note that whatever is returned doesn't have to be an actual\n" \
":class:`Cursor` instance, and just needs to have the methods present\n" \
"that are actually called.  These are likely to be `execute`,\n" \
"`executemany`, `close` etc.\n" 

#define  Connection_data_version_DOC "Connection.data_version(schema: Optional[str] = None) -> int\n\n" \
"Unlike `pragma data_version\n" \
"<https://sqlite.org/pragma.html#pragma_data_version>`__ this value\n" \
"updates when changes are made by other connections, **AND** this one.\n" \
"\n" \
":param schema: `schema` is `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__,\n" \
"    defaulting to `main` if not supplied.\n" \
"\n" \
"See the :ref:`example <example_caching>`.\n" \
"\n" \
"Calls: `sqlite3_file_control <https://sqlite.org/c3ref/file_control.html>`__\n" 

#define Connection_data_version_KWNAMES "schema"
#define Connection_data_version_USAGE "Connection.data_version(schema: Optional[str] = None) -> int"

#define Connection_data_version_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(schema == 0); \
} while(0)


#define  Connection_db_filename_DOC "Connection.db_filename(name: str) -> str\n\n" \
"Returns the full filename of the named (attached) database.  The\n" \
"main is `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define Connection_db_filename_KWNAMES "name"
#define Connection_db_filename_USAGE "Connection.db_filename(name: str) -> str"

#define Connection_db_filename_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_db_names_DOC "Connection.db_names() -> list[str]\n\n" \
"Returns the list of database names.  For example the first database\n" \
"is named 'main', the next 'temp', and the rest with the name provided\n" \
"in `ATTACH <https://www.sqlite.org/lang_attach.html>`__\n" \
"\n" \
"Calls: `sqlite3_db_name <https://sqlite.org/c3ref/db_name.html>`__\n" 

#define  Connection_deserialize_DOC "Connection.deserialize(name: str, contents: Buffer) -> None\n\n" \
"Replaces the named database with an in-memory copy of *contents*.\n" \
"*name* is `main`, `temp`, the name in `ATTACH\n" \
"<https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"The resulting database is in-memory, read-write, and the memory is\n" \
"owned, resized, and freed by SQLite.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.serialize`\n" \
"\n" \
"Calls: `sqlite3_deserialize <https://sqlite.org/c3ref/deserialize.html>`__\n" 

#define Connection_deserialize_KWNAMES "name", "contents"
#define Connection_deserialize_USAGE "Connection.deserialize(name: str, contents: Buffer) -> None"

#define Connection_deserialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(contents), PyObject *)); \
} while(0)


#define  Connection_drop_modules_DOC "Connection.drop_modules(keep: Optional[Iterable[str]]) -> None\n\n" \
"If *keep* is *None* then all registered virtual tables are dropped.\n" \
"\n" \
"Otherwise *keep* is a sequence of strings, naming the virtual tables that\n" \
"are kept, dropping all others.\n" 

#define Connection_drop_modules_KWNAMES "keep"
#define Connection_drop_modules_USAGE "Connection.drop_modules(keep: Optional[Iterable[str]]) -> None"

#define Connection_drop_modules_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(keep), PyObject *)); \
} while(0)


#define  Connection_enable_load_extension_DOC "Connection.enable_load_extension(enable: bool) -> None\n\n" \
"Enables/disables `extension loading\n" \
"<https://www.sqlite.org/loadext.html>`_\n" \
"which is disabled by default.\n" \
"\n" \
":param enable: If True then extension loading is enabled, else it is disabled.\n" \
"\n" \
"Calls: `sqlite3_enable_load_extension <https://sqlite.org/c3ref/enable_load_extension.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.load_extension`\n" 

#define Connection_enable_load_extension_KWNAMES "enable"
#define Connection_enable_load_extension_USAGE "Connection.enable_load_extension(enable: bool) -> None"

#define Connection_enable_load_extension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define Connection_enable_load_extension_OLDNAME "enableloadextension"
#define Connection_enable_load_extension_OLDDOC Connection_enable_load_extension_USAGE "\n(Old less clear name enableloadextension)"

#define  Connection_enter_DOC "Connection.__enter__() -> Connection\n\n" \
"You can use the database as a `context manager\n" \
"<https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* a transaction is\n" \
"started.  If the block finishes with an exception then the\n" \
"transaction is rolled back, otherwise it is committed.  For example::\n" \
"\n" \
"  with connection:\n" \
"      connection.execute(\"....\")\n" \
"      with connection:\n" \
"          # nested is supported\n" \
"          call_function(connection)\n" \
"          connection.execute(\"...\")\n" \
"          with connection as db:\n" \
"              # You can also use 'as'\n" \
"              call_function2(db)\n" \
"              db.execute(\"...\")\n" \
"\n" \
"Behind the scenes `savepoints <https://sqlite.org/lang_savepoint.html>`__\n" \
" are used to provide nested transactions.\n" 

#define  Connection_exec_trace_DOC ":type: Optional[ExecTracer]\n" \
"\n" \
"Called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"Connection, unless the :class:`Cursor` installed its own\n" \
"tracer. Your execution tracer can also abort execution of a\n" \
"statement.\n" \
"\n" \
"If *callable* is *None* then any existing execution tracer is\n" \
"removed.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Cursor.exec_trace`\n" 

#define Connection_exec_trace_OLDNAME "exectrace"
#define Connection_exec_trace_USAGE "Connection.exec_trace"
#define Connection_exec_trace_OLDDOC Connection_exec_trace_USAGE "\n(Old less clear name exectrace)"

#define  Connection_execute_DOC "Connection.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor\n\n" \
"Executes the statements using the supplied bindings.  Execution\n" \
"returns when the first row is available or all statements have\n" \
"completed.  (A cursor is automatically obtained).\n" \
"\n" \
"For pragmas you should use :meth:`pragma` which handles quoting and\n" \
"caching correctly.\n" \
"\n" \
"See :meth:`Cursor.execute` for more details, and the :ref:`example <example_executing_sql>`.\n" 

#define  Connection_executemany_DOC "Connection.executemany(statements: str, sequenceofbindings:Iterable[Bindings], *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor\n\n" \
"This method is for when you want to execute the same statements over a\n" \
"sequence of bindings, such as inserting into a database.  (A cursor is\n" \
"automatically obtained).\n" \
"\n" \
"See :meth:`Cursor.executemany` for more details, and the :ref:`example <example_executemany>`.\n" 

#define  Connection_exit_DOC "Connection.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~Connection.__enter__`.  If no exception happened then\n" \
"the pending transaction is committed, while an exception results in a\n" \
"rollback.\n" 

#define Connection_exit_KWNAMES "etype", "evalue", "etraceback"
#define Connection_exit_USAGE "Connection.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]"

#define Connection_exit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(etype), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(evalue), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(etraceback), PyObject *)); \
} while(0)


#define  Connection_file_control_DOC "Connection.file_control(dbname: str, op: int, pointer: int) -> bool\n\n" \
"Calls the :meth:`~VFSFile.xFileControl` method on the :ref:`VFS`\n" \
"implementing :class:`file access <VFSFile>` for the database.\n" \
"\n" \
":param dbname: The name of the database to affect.  `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
":param op: A `numeric code\n" \
"  <https://sqlite.org/c3ref/c_fcntl_lockstate.html>`_ with values less\n" \
"  than 100 reserved for SQLite internal use.\n" \
":param pointer: A number which is treated as a ``void pointer`` at the C level.\n" \
"\n" \
":returns: True or False indicating if the VFS understood the op.\n" \
"\n" \
"The :ref:`example <example_filecontrol>` shows getting\n" \
"`SQLITE_FCNTL_DATA_VERSION\n" \
"<https://sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntldataversion>`__.\n" \
"\n" \
"If you want data returned back then the *pointer* needs to point to\n" \
"something mutable.  Here is an example using :mod:`ctypes` of\n" \
"passing a Python dictionary to :meth:`~VFSFile.xFileControl` which\n" \
"can then modify the dictionary to set return values::\n" \
"\n" \
"  obj={\"foo\": 1, 2: 3}                 # object we want to pass\n" \
"  objwrap=ctypes.py_object(obj)        # objwrap must live before and after the call else\n" \
"                                       # it gets garbage collected\n" \
"  connection.file_control(\n" \
"           \"main\",                     # which db\n" \
"           123,                        # our op code\n" \
"           ctypes.addressof(objwrap))  # get pointer\n" \
"\n" \
"The :meth:`~VFSFile.xFileControl` method then looks like this::\n" \
"\n" \
"  def xFileControl(self, op, pointer):\n" \
"      if op==123:                      # our op code\n" \
"          obj=ctypes.py_object.from_address(pointer).value\n" \
"          # play with obj - you can use id() to verify it is the same\n" \
"          print(obj[\"foo\"])\n" \
"          obj[\"result\"]=\"it worked\"\n" \
"          return True\n" \
"      else:\n" \
"          # pass to parent/superclass\n" \
"          return super().xFileControl(op, pointer)\n" \
"\n" \
"This is how you set the chunk size by which the database grows.  Do\n" \
"not combine it into one line as the c_int would be garbage collected\n" \
"before the file control call is made::\n" \
"\n" \
"   chunksize=ctypes.c_int(32768)\n" \
"   connection.file_control(\"main\", apsw.SQLITE_FCNTL_CHUNK_SIZE, ctypes.addressof(chunksize))\n" \
"\n" \
"Calls: `sqlite3_file_control <https://sqlite.org/c3ref/file_control.html>`__\n" 

#define Connection_file_control_KWNAMES "dbname", "op", "pointer"
#define Connection_file_control_USAGE "Connection.file_control(dbname: str, op: int, pointer: int) -> bool"

#define Connection_file_control_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define Connection_file_control_OLDNAME "filecontrol"
#define Connection_file_control_OLDDOC Connection_file_control_USAGE "\n(Old less clear name filecontrol)"

#define  Connection_filename_DOC ":type: str\n" \
"\n" \
"The filename of the database.\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define  Connection_filename_journal_DOC ":type: str\n" \
"\n" \
"The journal filename of the database,\n" \
"\n" \
"Calls: `sqlite3_filename_journal <https://sqlite.org/c3ref/filename_database.html>`__\n" 

#define  Connection_filename_wal_DOC ":type: str\n" \
"\n" \
"The WAL filename of the database,\n" \
"\n" \
"Calls: `sqlite3_filename_wal <https://sqlite.org/c3ref/filename_database.html>`__\n" 

#define  Connection_fts5_tokenizer_DOC "Connection.fts5_tokenizer(name: str, args: list[str] | None = None) -> apsw.FTS5Tokenizer\n\n" \
"Returns the named tokenizer initialized with ``args``.  Names are case insensitive.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :meth:`register_fts5_tokenizer`\n" \
"    * :doc:`textsearch`\n" 

#define Connection_fts5_tokenizer_KWNAMES "name", "args"
#define Connection_fts5_tokenizer_USAGE "Connection.fts5_tokenizer(name: str, args: list[str] | None = None) -> apsw.FTS5Tokenizer"

#define Connection_fts5_tokenizer_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(args), PyObject *)); \
  assert(args == NULL); \
} while(0)


#define  Connection_fts5_tokenizer_available_DOC "Connection.fts5_tokenizer_available(name: str) -> bool\n\n" \
"Checks if the named tokenizer is registered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :meth:`fts5_tokenizer`\n" \
"    * :doc:`textsearch`\n" \
"    * `FTS5 documentation <https://www.sqlite.org/fts5.html#custom_tokenizers>`__\n" 

#define Connection_fts5_tokenizer_available_KWNAMES "name"
#define Connection_fts5_tokenizer_available_USAGE "Connection.fts5_tokenizer_available(name: str) -> bool"

#define Connection_fts5_tokenizer_available_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_get_autocommit_DOC "Connection.get_autocommit() -> bool\n\n" \
"Returns if the Connection is in auto commit mode (ie not in a transaction).\n" \
"\n" \
"Calls: `sqlite3_get_autocommit <https://sqlite.org/c3ref/get_autocommit.html>`__\n" 

#define Connection_get_autocommit_OLDNAME "getautocommit"
#define Connection_get_autocommit_USAGE "Connection.get_autocommit() -> bool"
#define Connection_get_autocommit_OLDDOC Connection_get_autocommit_USAGE "\n(Old less clear name getautocommit)"

#define  Connection_get_exec_trace_DOC "Connection.get_exec_trace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed :attr:`execution tracer\n" \
"<Connection.exec_trace>`\n" 

#define Connection_get_exec_trace_OLDNAME "getexectrace"
#define Connection_get_exec_trace_USAGE "Connection.get_exec_trace() -> Optional[ExecTracer]"
#define Connection_get_exec_trace_OLDDOC Connection_get_exec_trace_USAGE "\n(Old less clear name getexectrace)"

#define  Connection_get_row_trace_DOC "Connection.get_row_trace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed :attr:`row tracer\n" \
"<Connection.row_trace>`\n" 

#define Connection_get_row_trace_OLDNAME "getrowtrace"
#define Connection_get_row_trace_USAGE "Connection.get_row_trace() -> Optional[RowTracer]"
#define Connection_get_row_trace_OLDDOC Connection_get_row_trace_USAGE "\n(Old less clear name getrowtrace)"

#define  Connection_in_transaction_DOC ":type: bool\n" \
"\n" \
"True if currently in a transaction, else False\n" \
"\n" \
"Calls: `sqlite3_get_autocommit <https://sqlite.org/c3ref/get_autocommit.html>`__\n" 

#define  Connection_init_DOC "Connection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)\n\n" \
"Opens the named database.  You can use ``:memory:`` to get a private temporary\n" \
"in-memory database that is not shared with any other connections.\n" \
"\n" \
":param flags: One or more of the `open flags <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ orred together\n" \
":param vfs: The name of the `vfs <https://sqlite.org/c3ref/vfs.html>`_ to use.  If *None* then the default\n" \
"   vfs will be used.\n" \
"\n" \
":param statementcachesize: Use zero to disable the statement cache,\n" \
"  or a number larger than the total distinct SQL statements you\n" \
"  execute frequently.\n" \
"\n" \
"Calls: `sqlite3_open_v2 <https://sqlite.org/c3ref/open.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :attr:`apsw.connection_hooks`\n" \
"  * :ref:`statementcache`\n" \
"  * :ref:`vfs`\n" 

#define Connection_init_KWNAMES "filename", "flags", "vfs", "statementcachesize"
#define Connection_init_USAGE "Connection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)"

#define Connection_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE)); \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(vfs == 0); \
  assert(__builtin_types_compatible_p(typeof(statementcachesize), int)); \
  assert(statementcachesize == (100)); \
} while(0)


#define  Connection_interrupt_DOC "Connection.interrupt() -> None\n\n" \
"Causes all pending operations on the database to abort at the\n" \
"earliest opportunity. You can call this from any thread.  For\n" \
"example you may have a long running query when the user presses the\n" \
"stop button in your user interface.  :exc:`InterruptError`\n" \
"will be raised in the queries that got interrupted.\n" \
"\n" \
"Calls: `sqlite3_interrupt <https://sqlite.org/c3ref/interrupt.html>`__\n" 

#define  Connection_is_interrupted_DOC ":type: bool\n" \
"\n" \
"Indicates if this connection has been interrupted.\n" \
"\n" \
"Calls: `sqlite3_is_interrupted <https://sqlite.org/c3ref/interrupt.html>`__\n" 

#define  Connection_last_insert_rowid_DOC "Connection.last_insert_rowid() -> int\n\n" \
"Returns the integer key of the most recent insert in the database.\n" \
"\n" \
"Calls: `sqlite3_last_insert_rowid <https://sqlite.org/c3ref/last_insert_rowid.html>`__\n" 

#define  Connection_limit_DOC "Connection.limit(id: int, newval: int = -1) -> int\n\n" \
"If called with one parameter then the current limit for that *id* is\n" \
"returned.  If called with two then the limit is set to *newval*.\n" \
"\n" \
"\n" \
":param id: One of the `runtime limit ids <https://sqlite.org/c3ref/c_limit_attached.html>`_\n" \
":param newval: The new limit.  This is a 32 bit signed integer even on 64 bit platforms.\n" \
"\n" \
":returns: The limit in place on entry to the call.\n" \
"\n" \
"Calls: `sqlite3_limit <https://sqlite.org/c3ref/limit.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_limits>`\n" 

#define Connection_limit_KWNAMES "id", "newval"
#define Connection_limit_USAGE "Connection.limit(id: int, newval: int = -1) -> int"

#define Connection_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(id), int)); \
  assert(__builtin_types_compatible_p(typeof(newval), int)); \
  assert(newval == (-1)); \
} while(0)


#define  Connection_load_extension_DOC "Connection.load_extension(filename: str, entrypoint: Optional[str] = None) -> None\n\n" \
"Loads *filename* as an `extension <https://www.sqlite.org/loadext.html>`_\n" \
"\n" \
":param filename: The file to load.\n" \
"\n" \
":param entrypoint: The initialization method to call.  If this\n" \
"  parameter is not supplied then the SQLite default of\n" \
"  ``sqlite3_extension_init`` is used.\n" \
"\n" \
":raises ExtensionLoadingError: If the extension could not be\n" \
"  loaded.  The exception string includes more details.\n" \
"\n" \
"Calls: `sqlite3_load_extension <https://sqlite.org/c3ref/load_extension.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.enable_load_extension`\n" 

#define Connection_load_extension_KWNAMES "filename", "entrypoint"
#define Connection_load_extension_USAGE "Connection.load_extension(filename: str, entrypoint: Optional[str] = None) -> None"

#define Connection_load_extension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(entrypoint), const char *)); \
  assert(entrypoint == 0); \
} while(0)


#define Connection_load_extension_OLDNAME "loadextension"
#define Connection_load_extension_OLDDOC Connection_load_extension_USAGE "\n(Old less clear name loadextension)"

#define  Connection_open_flags_DOC ":type: int\n" \
"\n" \
"The combination of :attr:`flags <apsw.mapping_open_flags>` used to open the database.\n" 

#define  Connection_open_vfs_DOC ":type: str\n" \
"\n" \
"The string name of the vfs used to open the database.\n" 

#define  Connection_overload_function_DOC "Connection.overload_function(name: str, nargs: int) -> None\n\n" \
"Registers a placeholder function so that a virtual table can provide an implementation via\n" \
":meth:`VTTable.FindFunction`.\n" \
"\n" \
":param name: Function name\n" \
":param nargs: How many arguments the function takes\n" \
"\n" \
"  Calls: `sqlite3_overload_function <https://sqlite.org/c3ref/overload_function.html>`__\n" 

#define Connection_overload_function_KWNAMES "name", "nargs"
#define Connection_overload_function_USAGE "Connection.overload_function(name: str, nargs: int) -> None"

#define Connection_overload_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(nargs), int)); \
} while(0)


#define Connection_overload_function_OLDNAME "overloadfunction"
#define Connection_overload_function_OLDDOC Connection_overload_function_USAGE "\n(Old less clear name overloadfunction)"

#define  Connection_pragma_DOC "Connection.pragma(name: str, value: Optional[SQLiteValue] = None, *, schema: Optional[str] = None) -> Any\n\n" \
"Issues the pragma (with the value if supplied) and returns the result with\n" \
":attr:`the least amount of structure <Cursor.get>`.  For example\n" \
":code:`pragma(\"user_version\")` will return just the number, while\n" \
":code:`pragma(\"journal_mode\", \"WAL\")` will return the journal mode\n" \
"now in effect.\n" \
"\n" \
"Pragmas do not support bindings, so this method is a convenient\n" \
"alternative to composing SQL text.  Pragmas are often executed\n" \
"while being prepared, instead of when run like regular SQL.  They\n" \
"may also contain encryption keys.  This method ensures they are\n" \
"not cached to avoid problems.\n" \
"\n" \
"Use the `schema` parameter to run the pragma against a different\n" \
"attached database (eg ``temp``).\n" \
"\n" \
"* :ref:`Example <example_pragma>`\n" 

#define Connection_pragma_KWNAMES "name", "value", "schema"
#define Connection_pragma_USAGE "Connection.pragma(name: str, value: Optional[SQLiteValue] = None, *, schema: Optional[str] = None) -> Any"

#define Connection_pragma_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(value), PyObject *)); \
  assert(value == NULL); \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(schema == 0); \
} while(0)


#define  Connection_preupdate_hook_DOC "Connection.preupdate_hook(callback: Optional[PreupdateHook], *, id: Optional[Any] = None) -> None\n\n" \
"A callback just after a database row is updated.  You can have multiple hooks at once\n" \
"(managed by APSW) by specifying different ``id`` for each.  Using :class:`None` for\n" \
"``callback`` will remove it.\n" \
"\n" \
"SQLite provides no way to report errors from the callback.  The SQLite level update\n" \
"will always succeed, with Python exceptions reported when control returns to Python\n" \
"code.\n" \
"\n" \
".. important::\n" \
"\n" \
"   The :doc:`session` extension uses the preupdate hook, and will **CRASH\n" \
"   THE PROCESS** if you register a hook via this method, and then create\n" \
"   a :class:`Session`.\n" \
"\n" \
"SQLlite must be compiled with ``SQLITE_ENABLE_PREUPDATE_HOOK`` and this must be known\n" \
"to APSW at compile time.  If not, this API and :class:`PreUpdate` will not be present.\n" \
"\n" \
"You do not get calls undoing changes when a transaction is\n" \
"aborted/rolled back.  Consequently you can't use this hook to track\n" \
"the current state of the database.  The approach taken by the\n" \
":doc:`session` is to note the rowid (or primary keys for without rowid\n" \
"tables), and initial values the first time that a row is seen.  When a\n" \
"changeset is requested, it compares the contents of the row now to the row\n" \
"then, and generates the appropriate changeset entry.\n" \
"\n" \
"Calls: `sqlite3_preupdate_hook <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define Connection_preupdate_hook_KWNAMES "callback", "id"
#define Connection_preupdate_hook_USAGE "Connection.preupdate_hook(callback: Optional[PreupdateHook], *, id: Optional[Any] = None) -> None"

#define Connection_preupdate_hook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(id), PyObject *)); \
  assert(id == NULL); \
} while(0)


#define  Connection_read_DOC "Connection.read(schema: str, which: int, offset: int, amount: int) -> tuple[bool, bytes]\n\n" \
"Invokes the underlying VFS method to read data from the database.  It\n" \
"is strongly recommended to read aligned complete pages, since that is\n" \
"only what SQLite does.\n" \
"\n" \
"`schema` is `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"`which` is 0 for the database file, 1 for the journal.\n" \
"\n" \
"The return value is a tuple of a boolean indicating a complete read if\n" \
"True, and the bytes read which will always be the amount requested\n" \
"in size.\n" \
"\n" \
"`SQLITE_IOERR_SHORT_READ` will give a `False` value for the boolean,\n" \
"and there is no way of knowing how much was read.\n" \
"\n" \
"Implemented using `SQLITE_FCNTL_FILE_POINTER` and `SQLITE_FCNTL_JOURNAL_POINTER`.\n" \
"Errors will usually be generic `SQLITE_ERROR` with no message.\n" \
"\n" \
"Calls: `sqlite3_file_control <https://sqlite.org/c3ref/file_control.html>`__\n" 

#define Connection_read_KWNAMES "schema", "which", "offset", "amount"
#define Connection_read_USAGE "Connection.read(schema: str, which: int, offset: int, amount: int) -> tuple[bool, bytes]"

#define Connection_read_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Connection_readonly_DOC "Connection.readonly(name: str) -> bool\n\n" \
"True or False if the named (attached) database was opened readonly or file\n" \
"permissions don't allow writing.  The name is `main`, `temp`, the\n" \
"name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"An exception is raised if the database doesn't exist.\n" \
"\n" \
"Calls: `sqlite3_db_readonly <https://sqlite.org/c3ref/db_readonly.html>`__\n" 

#define Connection_readonly_KWNAMES "name"
#define Connection_readonly_USAGE "Connection.readonly(name: str) -> bool"

#define Connection_readonly_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_register_fts5_function_DOC "Connection.register_fts5_function(name: str, function: FTS5Function) -> None\n\n" \
"Registers the (case insensitive) named function used as an `auxiliary\n" \
"function  <https://www.sqlite.org/fts5.html#custom_auxiliary_functions>`__.\n" \
"\n" \
"The first parameter to the function will be :class:`FTS5ExtensionApi`\n" \
"and the rest will be the function arguments at the SQL level.\n" 

#define Connection_register_fts5_function_KWNAMES "name", "function"
#define Connection_register_fts5_function_USAGE "Connection.register_fts5_function(name: str, function: FTS5Function) -> None"

#define Connection_register_fts5_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(function), PyObject *)); \
} while(0)


#define  Connection_register_fts5_tokenizer_DOC "Connection.register_fts5_tokenizer(name: str, tokenizer_factory: FTS5TokenizerFactory) -> None\n\n" \
"Registers a tokenizer factory.  Names are case insensitive.  It is not possible to\n" \
"unregister a tokenizer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :meth:`fts5_tokenizer`\n" \
"    * :doc:`textsearch`\n" \
"    * `FTS5 documentation <https://www.sqlite.org/fts5.html#custom_tokenizers>`__\n" 

#define Connection_register_fts5_tokenizer_KWNAMES "name", "tokenizer_factory"
#define Connection_register_fts5_tokenizer_USAGE "Connection.register_fts5_tokenizer(name: str, tokenizer_factory: FTS5TokenizerFactory) -> None"

#define Connection_register_fts5_tokenizer_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(tokenizer_factory), PyObject *)); \
} while(0)


#define  Connection_release_memory_DOC "Connection.release_memory() -> None\n\n" \
"Attempts to free as much heap memory as possible used by this connection.\n" \
"\n" \
"Calls: `sqlite3_db_release_memory <https://sqlite.org/c3ref/db_release_memory.html>`__\n" 

#define  Connection_row_trace_DOC ":type: Optional[RowTracer]\n" \
"\n" \
"Called with the cursor and row being returned for\n" \
":class:`cursors <Cursor>` associated with this Connection, unless\n" \
"the Cursor installed its own tracer.  You can change the data that\n" \
"is returned or cause the row to be skipped altogether.\n" \
"\n" \
"If *callable* is *None* then any existing row tracer is\n" \
"removed.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Cursor.exec_trace`\n" 

#define Connection_row_trace_OLDNAME "rowtrace"
#define Connection_row_trace_USAGE "Connection.row_trace"
#define Connection_row_trace_OLDDOC Connection_row_trace_USAGE "\n(Old less clear name rowtrace)"

#define  Connection_serialize_DOC "Connection.serialize(name: str) -> bytes\n\n" \
"Returns a memory copy of the database. *name* is `main`, `temp`, the name\n" \
"in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"The memory copy is the same as if the database was backed up to\n" \
"disk.\n" \
"\n" \
"If the database name doesn't exist, then None is returned, not an\n" \
"exception (this is SQLite's behaviour).  One exception is than an\n" \
"empty temp will result in a None return.\n" \
"\n" \
" .. seealso::\n" \
"\n" \
"   * :meth:`Connection.deserialize`\n" \
"\n" \
" Calls: `sqlite3_serialize <https://sqlite.org/c3ref/serialize.html>`__\n" 

#define Connection_serialize_KWNAMES "name"
#define Connection_serialize_USAGE "Connection.serialize(name: str) -> bytes"

#define Connection_serialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_set_authorizer_DOC "Connection.set_authorizer(callable: Optional[Authorizer]) -> None\n\n" \
"Sets the :attr:`authorizer`\n" 

#define Connection_set_authorizer_KWNAMES "callable"
#define Connection_set_authorizer_USAGE "Connection.set_authorizer(callable: Optional[Authorizer]) -> None"

#define Connection_set_authorizer_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_authorizer_OLDNAME "setauthorizer"
#define Connection_set_authorizer_OLDDOC Connection_set_authorizer_USAGE "\n(Old less clear name setauthorizer)"

#define  Connection_set_busy_handler_DOC "Connection.set_busy_handler(callable: Optional[Callable[[int], bool]]) -> None\n\n" \
"Sets the busy handler to callable. callable will be called with one\n" \
"integer argument which is the number of prior calls to the busy\n" \
"callback for the same lock. If the busy callback returns False,\n" \
"then SQLite returns *SQLITE_BUSY* to the calling code. If\n" \
"the callback returns True, then SQLite tries to open the table\n" \
"again and the cycle repeats.\n" \
"\n" \
"If you previously called :meth:`~Connection.set_busy_timeout` then\n" \
"calling this overrides that.\n" \
"\n" \
"Passing None unregisters the existing handler.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.set_busy_timeout`\n" \
"  * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_handler <https://sqlite.org/c3ref/busy_handler.html>`__\n" 

#define Connection_set_busy_handler_KWNAMES "callable"
#define Connection_set_busy_handler_USAGE "Connection.set_busy_handler(callable: Optional[Callable[[int], bool]]) -> None"

#define Connection_set_busy_handler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_busy_handler_OLDNAME "setbusyhandler"
#define Connection_set_busy_handler_OLDDOC Connection_set_busy_handler_USAGE "\n(Old less clear name setbusyhandler)"

#define  Connection_set_busy_timeout_DOC "Connection.set_busy_timeout(milliseconds: int) -> None\n\n" \
"If the database is locked such as when another connection is making\n" \
"changes, SQLite will keep retrying.  This sets the maximum amount of\n" \
"time SQLite will keep retrying before giving up.  If the database is\n" \
"still busy then :class:`apsw.BusyError` will be returned.\n" \
"\n" \
":param milliseconds: Maximum thousandths of a second to wait.\n" \
"\n" \
"If you previously called :meth:`~Connection.set_busy_handler` then\n" \
"calling this overrides that.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :meth:`Connection.set_busy_handler`\n" \
"   * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_timeout <https://sqlite.org/c3ref/busy_timeout.html>`__\n" 

#define Connection_set_busy_timeout_KWNAMES "milliseconds"
#define Connection_set_busy_timeout_USAGE "Connection.set_busy_timeout(milliseconds: int) -> None"

#define Connection_set_busy_timeout_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(milliseconds), int)); \
} while(0)


#define Connection_set_busy_timeout_OLDNAME "setbusytimeout"
#define Connection_set_busy_timeout_OLDDOC Connection_set_busy_timeout_USAGE "\n(Old less clear name setbusytimeout)"

#define  Connection_set_commit_hook_DOC "Connection.set_commit_hook(callable: Optional[CommitHook], *, id: Optional[Any] = None) -> None\n\n" \
"*callable* will be called just before a commit.  It should return\n" \
"False for the commit to go ahead and True for it to be turned\n" \
"into a rollback. In the case of an exception in your callable, a\n" \
"True (rollback) value is returned.  Pass None to unregister\n" \
"the existing hook.\n" \
"\n" \
"You can have multiple hooks at once (managed by APSW) by specifying\n" \
"different ``id`` for each one.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_commit_hook>`\n" \
"\n" \
"Calls: `sqlite3_commit_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_set_commit_hook_KWNAMES "callable", "id"
#define Connection_set_commit_hook_USAGE "Connection.set_commit_hook(callable: Optional[CommitHook], *, id: Optional[Any] = None) -> None"

#define Connection_set_commit_hook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(id), PyObject *)); \
  assert(id == NULL); \
} while(0)


#define Connection_set_commit_hook_OLDNAME "setcommithook"
#define Connection_set_commit_hook_OLDDOC Connection_set_commit_hook_USAGE "\n(Old less clear name setcommithook)"

#define  Connection_set_exec_trace_DOC "Connection.set_exec_trace(callable: Optional[ExecTracer]) -> None\n\n" \
"Method to set :attr:`Connection.exec_trace`\n" 

#define Connection_set_exec_trace_KWNAMES "callable"
#define Connection_set_exec_trace_USAGE "Connection.set_exec_trace(callable: Optional[ExecTracer]) -> None"

#define Connection_set_exec_trace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_exec_trace_OLDNAME "setexectrace"
#define Connection_set_exec_trace_OLDDOC Connection_set_exec_trace_USAGE "\n(Old less clear name setexectrace)"

#define  Connection_set_last_insert_rowid_DOC "Connection.set_last_insert_rowid(rowid: int) -> None\n\n" \
"Sets the value calls to :meth:`last_insert_rowid` will return.\n" \
"\n" \
"Calls: `sqlite3_set_last_insert_rowid <https://sqlite.org/c3ref/set_last_insert_rowid.html>`__\n" 

#define Connection_set_last_insert_rowid_KWNAMES "rowid"
#define Connection_set_last_insert_rowid_USAGE "Connection.set_last_insert_rowid(rowid: int) -> None"

#define Connection_set_last_insert_rowid_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Connection_set_profile_DOC "Connection.set_profile(callable: Optional[Callable[[str, int], None]]) -> None\n\n" \
"Sets a callable which is invoked at the end of execution of each\n" \
"statement and passed the statement string and how long it took to\n" \
"execute. (The execution time is in nanoseconds.) Note that it is\n" \
"called only on completion. If for example you do a ``SELECT`` and only\n" \
"read the first result, then you won't reach the end of the statement.\n" \
"\n" \
"Calls: `sqlite3_trace_v2 <https://sqlite.org/c3ref/trace_v2.html>`__\n" 

#define Connection_set_profile_KWNAMES "callable"
#define Connection_set_profile_USAGE "Connection.set_profile(callable: Optional[Callable[[str, int], None]]) -> None"

#define Connection_set_profile_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_profile_OLDNAME "setprofile"
#define Connection_set_profile_OLDDOC Connection_set_profile_USAGE "\n(Old less clear name setprofile)"

#define  Connection_set_progress_handler_DOC "Connection.set_progress_handler(callable: Optional[Callable[[], bool]], nsteps: int = 100, *, id: Optional[Any] = None) -> None\n\n" \
"Sets a callable which is invoked every *nsteps* SQLite inststructions.\n" \
"The callable should return True to abort or False to continue. (If\n" \
"there is an error in your Python *callable* then True/abort will be\n" \
"returned).  SQLite raises :exc:`InterruptError` for aborts.\n" \
"\n" \
"Use :class:`None` to cancel the progress handler.  Multiple handlers\n" \
"can be present at once (implemented by APSW). Registered callbacks are\n" \
"distinguished by their ``id`` - an equality test is done to match ids.\n" \
"\n" \
"You can use :class:`apsw.ext.Trace` to see how many steps are used for\n" \
"a representative statement, or :class:`apsw.ext.ShowResourceUsage` to\n" \
"see how many are used in a block.  It will generally be several million\n" \
"per second.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_progress_handler>`\n" \
"\n" \
"Calls: `sqlite3_progress_handler <https://sqlite.org/c3ref/progress_handler.html>`__\n" 

#define Connection_set_progress_handler_KWNAMES "callable", "nsteps", "id"
#define Connection_set_progress_handler_USAGE "Connection.set_progress_handler(callable: Optional[Callable[[], bool]], nsteps: int = 100, *, id: Optional[Any] = None) -> None"

#define Connection_set_progress_handler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(nsteps), int)); \
  assert(nsteps == (100)); \
  assert(__builtin_types_compatible_p(typeof(id), PyObject *)); \
  assert(id == NULL); \
} while(0)


#define Connection_set_progress_handler_OLDNAME "setprogresshandler"
#define Connection_set_progress_handler_OLDDOC Connection_set_progress_handler_USAGE "\n(Old less clear name setprogresshandler)"

#define  Connection_set_rollback_hook_DOC "Connection.set_rollback_hook(callable: Optional[Callable[[], None]], *, id: Optional[Any] = None) -> None\n\n" \
"Sets a callable which is invoked during a rollback.  If *callable*\n" \
"is *None* then any existing rollback hook is unregistered.\n" \
"\n" \
"The *callable* is called with no parameters and the return value is ignored.\n" \
"\n" \
"You can have multiple hooks at once (managed by APSW) by specifying\n" \
"different ``id`` for each one.\n" \
"\n" \
"Calls: `sqlite3_rollback_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_set_rollback_hook_KWNAMES "callable", "id"
#define Connection_set_rollback_hook_USAGE "Connection.set_rollback_hook(callable: Optional[Callable[[], None]], *, id: Optional[Any] = None) -> None"

#define Connection_set_rollback_hook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(id), PyObject *)); \
  assert(id == NULL); \
} while(0)


#define Connection_set_rollback_hook_OLDNAME "setrollbackhook"
#define Connection_set_rollback_hook_OLDDOC Connection_set_rollback_hook_USAGE "\n(Old less clear name setrollbackhook)"

#define  Connection_set_row_trace_DOC "Connection.set_row_trace(callable: Optional[RowTracer]) -> None\n\n" \
"Method to set :attr:`Connection.row_trace`\n" 

#define Connection_set_row_trace_KWNAMES "callable"
#define Connection_set_row_trace_USAGE "Connection.set_row_trace(callable: Optional[RowTracer]) -> None"

#define Connection_set_row_trace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_row_trace_OLDNAME "setrowtrace"
#define Connection_set_row_trace_OLDDOC Connection_set_row_trace_USAGE "\n(Old less clear name setrowtrace)"

#define  Connection_set_update_hook_DOC "Connection.set_update_hook(callable: Optional[Callable[[int, str, str, int], None]]) -> None\n\n" \
"Calls *callable* whenever a row is updated, deleted or inserted.  If\n" \
"*callable* is *None* then any existing update hook is\n" \
"unregistered.  The update hook cannot make changes to the database while\n" \
"the query is still executing, but can record them for later use or\n" \
"apply them in a different connection.\n" \
"\n" \
"The update hook is called with 4 parameters:\n" \
"\n" \
"  type (int)\n" \
"    *SQLITE_INSERT*, *SQLITE_DELETE* or *SQLITE_UPDATE*\n" \
"  database name (str)\n" \
"    `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"  table name (str)\n" \
"    The table on which the update happened\n" \
"  rowid (int)\n" \
"    The affected row\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :ref:`Example <example_update_hook>`\n" \
"\n" \
"Calls: `sqlite3_update_hook <https://sqlite.org/c3ref/update_hook.html>`__\n" 

#define Connection_set_update_hook_KWNAMES "callable"
#define Connection_set_update_hook_USAGE "Connection.set_update_hook(callable: Optional[Callable[[int, str, str, int], None]]) -> None"

#define Connection_set_update_hook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_update_hook_OLDNAME "setupdatehook"
#define Connection_set_update_hook_OLDDOC Connection_set_update_hook_USAGE "\n(Old less clear name setupdatehook)"

#define  Connection_set_wal_hook_DOC "Connection.set_wal_hook(callable: Optional[Callable[[Connection, str, int], int]]) -> None\n\n" \
"*callable* will be called just after data is committed in :ref:`wal`\n" \
"mode.  It should return *SQLITE_OK* or an error code.  The\n" \
"callback is called with 3 parameters:\n" \
"\n" \
"  * The Connection\n" \
"  * The database name.  `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"  * The number of pages in the wal log\n" \
"\n" \
"You can pass in None in order to unregister an existing hook.\n" \
"\n" \
"Calls: `sqlite3_wal_hook <https://sqlite.org/c3ref/wal_hook.html>`__\n" 

#define Connection_set_wal_hook_KWNAMES "callable"
#define Connection_set_wal_hook_USAGE "Connection.set_wal_hook(callable: Optional[Callable[[Connection, str, int], int]]) -> None"

#define Connection_set_wal_hook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Connection_set_wal_hook_OLDNAME "setwalhook"
#define Connection_set_wal_hook_OLDDOC Connection_set_wal_hook_USAGE "\n(Old less clear name setwalhook)"

#define  Connection_setlk_timeout_DOC "Connection.setlk_timeout(ms: int, flags: int) -> None\n\n" \
"Sets a VFS level timeout.\n" \
"\n" \
"Calls: `sqlite3_setlk_timeout <https://sqlite.org/c3ref/setlk_timeout.html>`__\n" 

#define Connection_setlk_timeout_KWNAMES "ms", "flags"
#define Connection_setlk_timeout_USAGE "Connection.setlk_timeout(ms: int, flags: int) -> None"

#define Connection_setlk_timeout_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(ms), int)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  Connection_sqlite3_pointer_DOC "Connection.sqlite3_pointer() -> int\n\n" \
"Returns the underlying `sqlite3 *\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_ for the connection. This\n" \
"method is useful if there are other C level libraries in the same\n" \
"process and you want them to use the APSW connection handle. The value\n" \
"is returned as a number using `PyLong_FromVoidPtr\n" \
"<https://docs.python.org/3/c-api/long.html?highlight=pylong_fromvoidptr#c.PyLong_FromVoidPtr>`__\n" \
"under the hood. You should also ensure that you increment the\n" \
"reference count on the :class:`Connection` for as long as the other\n" \
"libraries are using the pointer.  It is also a very good idea to call\n" \
":meth:`sqlite_lib_version` and ensure it is the same as the other\n" \
"libraries.\n" 

#define Connection_sqlite3_pointer_OLDNAME "sqlite3pointer"
#define Connection_sqlite3_pointer_USAGE "Connection.sqlite3_pointer() -> int"
#define Connection_sqlite3_pointer_OLDDOC Connection_sqlite3_pointer_USAGE "\n(Old less clear name sqlite3pointer)"

#define  Connection_status_DOC "Connection.status(op: int, reset: bool = False) -> tuple[int, int]\n\n" \
"Returns current and highwater measurements for the database.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_dbstatus_options.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :func:`apsw.status` which does the same for SQLite as a whole\n" \
"  * :ref:`Example <example_status>`\n" \
"\n" \
"Calls: `sqlite3_db_status <https://sqlite.org/c3ref/db_status.html>`__\n" 

#define Connection_status_KWNAMES "op", "reset"
#define Connection_status_USAGE "Connection.status(op: int, reset: bool = False) -> tuple[int, int]"

#define Connection_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Connection_system_errno_DOC ":type: int\n" \
"\n" \
"The underlying system error code for the most recent I/O error.\n" \
"\n" \
"Calls: `sqlite3_system_errno <https://sqlite.org/c3ref/system_errno.html>`__\n" 

#define  Connection_table_exists_DOC "Connection.table_exists(dbname: Optional[str], table_name: str) -> bool\n\n" \
"Returns True if the named table exists, else False.\n" \
"\n" \
"``dbname`` is ``main``, ``temp``, the name in `ATTACH\n" \
"<https://sqlite.org/lang_attach.html>`__, or None to search  all\n" \
"databases\n" \
"\n" \
"Calls: `sqlite3_table_column_metadata <https://sqlite.org/c3ref/table_column_metadata.html>`__\n" 

#define Connection_table_exists_KWNAMES "dbname", "table_name"
#define Connection_table_exists_USAGE "Connection.table_exists(dbname: Optional[str], table_name: str) -> bool"

#define Connection_table_exists_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table_name), const char *)); \
} while(0)


#define  Connection_total_changes_DOC "Connection.total_changes() -> int\n\n" \
"Returns the total number of database rows that have be modified,\n" \
"inserted, or deleted since the database connection was opened.\n" \
"\n" \
"Calls: `sqlite3_total_changes64 <https://sqlite.org/c3ref/total_changes.html>`__\n" 

#define Connection_total_changes_OLDNAME "totalchanges"
#define Connection_total_changes_USAGE "Connection.total_changes() -> int"
#define Connection_total_changes_OLDDOC Connection_total_changes_USAGE "\n(Old less clear name totalchanges)"

#define  Connection_trace_v2_DOC "Connection.trace_v2(mask: int, callback: Optional[Callable[[dict], None]] = None, *, id: Optional[Any] = None) -> None\n\n" \
"Registers a trace callback.  Multiple traces can be active at once\n" \
"(implemented by APSW).  A callback of :class:`None` unregisters a\n" \
"trace.  Registered callbacks are distinguished by their ``id`` - an\n" \
"equality test is done to match ids.\n" \
"\n" \
"The callback is called with a dict of relevant values based on the\n" \
"code.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Type\n" \
"    - Explanation\n" \
"  * - code\n" \
"    - :class:`int`\n" \
"    - One of the `trace event codes <https://www.sqlite.org/c3ref/c_trace.html>`__\n" \
"  * - connection\n" \
"    - :class:`Connection`\n" \
"    - Connection this trace event belongs to\n" \
"  * - sql\n" \
"    - :class:`str`\n" \
"    - SQL text (except SQLITE_TRACE_ROW and SQLITE_TRACE_CLOSE).\n" \
"  * - id\n" \
"    - :class:`int`\n" \
"    - An opaque key to correlate events on the same statement.  The\n" \
"      id can be reused after SQLITE_TRACE_PROFILE.\n" \
"  * - trigger\n" \
"    - :class:`bool`\n" \
"    - If `trigger <https://www.sqlite.org/lang_createtrigger.html>`__\n" \
"      SQL is executing then this is ``True`` and the SQL is of the trigger.\n" \
"      Virtual table nested queries also come through as trigger activity.\n" \
"  * - total_changes\n" \
"    - :class:`int`\n" \
"    - Value of :meth:`total_changes`  (SQLITE_TRACE_STMT and SQLITE_TRACE_PROFILE only)\n" \
"  * - nanoseconds\n" \
"    - :class:`int`\n" \
"    - nanoseconds SQL took to execute (SQLITE_TRACE_PROFILE only)\n" \
"  * - stmt_status\n" \
"    - :class:`dict`\n" \
"    - SQLITE_TRACE_PROFILE only: Keys are names from `status parameters\n" \
"      <https://www.sqlite.org/c3ref/c_stmtstatus_counter.html>`__ - eg\n" \
"      *\"SQLITE_STMTSTATUS_VM_STEP\"* and corresponding integer values.\n" \
"      The counters are reset each time a statement\n" \
"      starts execution.  This includes any changes made by triggers.\n" \
"\n" \
"Note that SQLite ignores any errors from the trace callbacks, so\n" \
"whatever was being traced will still proceed.  Exceptions will be\n" \
"delivered when your Python code resumes.\n" \
"\n" \
"If you register for all trace types, the following sequence will happen.\n" \
"\n" \
"* SQLITE_TRACE_STMT with `trigger` `False` and an `id` and `sql` of\n" \
"  the statement.\n" \
"* Multiple times: SQLITE_TRACE_STMT with the same `id` and `trigger`\n" \
"  `True` if a trigger is executed.  The first time the `sql` will be\n" \
"  ``TRIGGER name`` and then subsequent calls will be lines of the\n" \
"  trigger.  This also happens for virtual tables that make queries.\n" \
"* Multiple times: SQLITE_TRACE_ROW with the same `id` for each time\n" \
"  execution stopped at a row. (Rows visited by triggers do not cause\n" \
"  thie event)\n" \
"* SQLITE_TRACE_PROFILE with the same `id` for any virtual table\n" \
"  queries - the ``sql`` will be of those queries\n" \
"* SQLITE_TRACE_PROFILE with the same `id` for the initial SQL.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_trace_v2>`\n" \
"  * :class:`apsw.ext.Trace`\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_trace_v2 <https://sqlite.org/c3ref/trace_v2.html>`__\n" \
"  * `sqlite3_stmt_status <https://sqlite.org/c3ref/stmt_status.html>`__\n" 

#define Connection_trace_v2_KWNAMES "mask", "callback", "id"
#define Connection_trace_v2_USAGE "Connection.trace_v2(mask: int, callback: Optional[Callable[[dict], None]] = None, *, id: Optional[Any] = None) -> None"

#define Connection_trace_v2_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(mask), int)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
  assert(callback == NULL); \
  assert(__builtin_types_compatible_p(typeof(id), PyObject *)); \
  assert(id == NULL); \
} while(0)


#define  Connection_txn_state_DOC "Connection.txn_state(schema: Optional[str] = None) -> int\n\n" \
"Returns the current transaction state of the database, or a specific schema\n" \
"if provided.  :attr:`apsw.mapping_txn_state` contains the values returned.\n" \
"\n" \
"Calls: `sqlite3_txn_state <https://sqlite.org/c3ref/txn_state.html>`__\n" 

#define Connection_txn_state_KWNAMES "schema"
#define Connection_txn_state_USAGE "Connection.txn_state(schema: Optional[str] = None) -> int"

#define Connection_txn_state_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(schema == 0); \
} while(0)


#define  Connection_vfsname_DOC "Connection.vfsname(dbname: str) -> str | None\n\n" \
"Issues the `SQLITE_FCNTL_VFSNAME\n" \
"<https://sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlvfsname>`__\n" \
"file control against the named database (`main`, `temp`, attached\n" \
"name).\n" \
"\n" \
"This is useful to see which VFS is in use, and if inheritance is used\n" \
"then ``/`` will separate the names.  If you have a :class:`VFSFile` in\n" \
"use then its fully qualified class name will also be included.\n" \
"\n" \
"If ``SQLITE_FCNTL_VFSNAME`` is not implemented, ``dbname`` is not a\n" \
"database name, or an error occurred then ``None`` is returned.\n" 

#define Connection_vfsname_KWNAMES "dbname"
#define Connection_vfsname_USAGE "Connection.vfsname(dbname: str) -> str | None"

#define Connection_vfsname_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
} while(0)


#define  Connection_vtab_config_DOC "Connection.vtab_config(op: int, val: int = 0) -> None\n\n" \
"Callable during virtual table :meth:`~VTModule.Connect`/:meth:`~VTModule.Create`.\n" \
"\n" \
"Calls: `sqlite3_vtab_config <https://sqlite.org/c3ref/vtab_config.html>`__\n" 

#define Connection_vtab_config_KWNAMES "op", "val"
#define Connection_vtab_config_USAGE "Connection.vtab_config(op: int, val: int = 0) -> None"

#define Connection_vtab_config_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(val), int)); \
  assert(val == (0)); \
} while(0)


#define  Connection_vtab_on_conflict_DOC "Connection.vtab_on_conflict() -> int\n\n" \
"Callable during virtual table :meth:`insert <VTTable.UpdateInsertRow>` or\n" \
":meth:`update <VTTable.UpdateChangeRow>`\n" \
"\n" \
"Calls: `sqlite3_vtab_on_conflict <https://sqlite.org/c3ref/vtab_on_conflict.html>`__\n" 

#define  Connection_wal_autocheckpoint_DOC "Connection.wal_autocheckpoint(n: int) -> None\n\n" \
"Sets how often the :ref:`wal` checkpointing is run.\n" \
"\n" \
" :param n: A number representing the checkpointing interval or\n" \
"   zero/negative to disable auto checkpointing.\n" \
"\n" \
"Calls: `sqlite3_wal_autocheckpoint <https://sqlite.org/c3ref/wal_autocheckpoint.html>`__\n" 

#define Connection_wal_autocheckpoint_KWNAMES "n"
#define Connection_wal_autocheckpoint_USAGE "Connection.wal_autocheckpoint(n: int) -> None"

#define Connection_wal_autocheckpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(n), int)); \
} while(0)


#define  Connection_wal_checkpoint_DOC "Connection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> tuple[int, int]\n\n" \
"Does a WAL checkpoint.  Has no effect if the database(s) are not in WAL mode.\n" \
"\n" \
"  :param dbname:  The name of the database or all databases if None\n" \
"\n" \
"  :param mode: One of the `checkpoint modes <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
"  :return: A tuple of the size of the WAL log in frames and the\n" \
"     number of frames checkpointed as described in the\n" \
"     `documentation\n" \
"     <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
"Calls: `sqlite3_wal_checkpoint_v2 <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__\n" 

#define Connection_wal_checkpoint_KWNAMES "dbname", "mode"
#define Connection_wal_checkpoint_USAGE "Connection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> tuple[int, int]"

#define Connection_wal_checkpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(dbname == 0); \
  assert(__builtin_types_compatible_p(typeof(mode), int)); \
  assert(mode == (SQLITE_CHECKPOINT_PASSIVE)); \
} while(0)


#define  Cursor_bindings_count_DOC ":type: int\n" \
"\n" \
"How many bindings are in the statement.  The ``?`` form\n" \
"results in the largest number.  For example you could do\n" \
"``SELECT ?123``` in which case the count will be ``123``.\n" \
"\n" \
"Calls: `sqlite3_bind_parameter_count <https://sqlite.org/c3ref/bind_parameter_count.html>`__\n" 

#define  Cursor_bindings_names_DOC ":type: tuple[str | None]\n" \
"\n" \
"A tuple of the name of each bind parameter, or None for no name.  The\n" \
"leading marker (``?:@$``) is omitted\n" \
"\n" \
".. note::\n" \
"\n" \
"  SQLite parameter numbering starts at ``1``, while Python\n" \
"  indexing starts at ``0``.\n" \
"\n" \
"Calls: `sqlite3_bind_parameter_name <https://sqlite.org/c3ref/bind_parameter_name.html>`__\n" 

#define  Cursor_class_DOC "\n" 

#define  Cursor_close_DOC "Cursor.close(force: bool = False) -> None\n\n" \
"It is very unlikely you will need to call this method.\n" \
"Cursors are automatically garbage collected and when there\n" \
"are none left will allow the connection to be garbage collected if\n" \
"it has no other references.\n" \
"\n" \
"A cursor is open if there are remaining statements to execute (if\n" \
"your query included multiple statements), or if you called\n" \
":meth:`~Cursor.executemany` and not all of the sequence of bindings\n" \
"have been used yet.\n" \
"\n" \
":param force: If False then you will get exceptions if there is\n" \
" remaining work to do be in the Cursor such as more statements to\n" \
" execute, more data from the executemany binding sequence etc. If\n" \
" force is True then all remaining work and state information will be\n" \
" silently discarded.\n" 

#define Cursor_close_KWNAMES "force"
#define Cursor_close_USAGE "Cursor.close(force: bool = False) -> None"

#define Cursor_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Cursor_connection_DOC ":type: Connection\n" \
"\n" \
":class:`Connection` this cursor is using\n" 

#define  Cursor_description_DOC ":type: tuple[tuple[str, str, None, None, None, None, None], ...]\n" \
"\n" \
"Based on the `DB-API cursor property\n" \
"<https://www.python.org/dev/peps/pep-0249/>`__, this returns the\n" \
"same as :meth:`get_description` but with 5 Nones appended because\n" \
"SQLite does not have the information.\n" 

#define  Cursor_description_full_DOC ":type: tuple[tuple[str, str, str, str, str], ...]\n" \
"\n" \
"Only present if SQLITE_ENABLE_COLUMN_METADATA was defined at\n" \
"compile time.\n" \
"\n" \
"Returns all information about the query result columns. In\n" \
"addition to the name and declared type, you also get the database\n" \
"name, table name, and origin name.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_column_name <https://sqlite.org/c3ref/column_name.html>`__\n" \
"  * `sqlite3_column_decltype <https://sqlite.org/c3ref/column_decltype.html>`__\n" \
"  * `sqlite3_column_database_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" \
"  * `sqlite3_column_table_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" \
"  * `sqlite3_column_origin_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" 

#define  Cursor_exec_trace_DOC ":type: Optional[ExecTracer]\n" \
"\n" \
"Called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"cursor.\n" \
"\n" \
"If *callable* is *None* then any existing execution tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`executiontracer`\n" \
"  * :attr:`Connection.exec_trace`\n" 

#define Cursor_exec_trace_OLDNAME "exectrace"
#define Cursor_exec_trace_USAGE "Cursor.exec_trace"
#define Cursor_exec_trace_OLDDOC Cursor_exec_trace_USAGE "\n(Old less clear name exectrace)"

#define  Cursor_execute_DOC "Cursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor\n\n" \
"Executes the statements using the supplied bindings.  Execution\n" \
"returns when the first row is available or all statements have\n" \
"completed.\n" \
"\n" \
":param statements: One or more SQL statements such as ``select *\n" \
"  from books`` or ``begin; insert into books ...; select\n" \
"  last_insert_rowid(); end``.\n" \
":param bindings: If supplied should either be a sequence or a dictionary.  Each item must be one of the :ref:`supported types <types>`,\n" \
"  :class:`zeroblob`, or a wrapped :ref:`Python object <pyobject>`\n" \
":param can_cache: If False then the statement cache will not be used to find an already prepared query, nor will it be\n" \
"  placed in the cache after execution\n" \
":param prepare_flags: `flags <https://sqlite.org/c3ref/c_prepare_normalize.html>`__ passed to\n" \
"  `sqlite_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
":param explain: If 0 or greater then the statement is passed to `sqlite3_stmt_explain <https://sqlite.org/c3ref/stmt_explain.html>`__\n" \
"   where you can force it to not be an explain, or force explain or explain query plan.\n" \
"\n" \
":raises TypeError: The bindings supplied were neither a dict nor a sequence\n" \
":raises BindingsError: You supplied too many or too few bindings for the statements\n" \
":raises IncompleteExecutionError: There are remaining unexecuted queries from your last execute\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"  * `sqlite3_step <https://sqlite.org/c3ref/step.html>`__\n" \
"  * `sqlite3_bind_int64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_null <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_text64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_double <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_blob64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_zeroblob64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_stmt_explain <https://sqlite.org/c3ref/stmt_explain.html>`__\n" 

#define Cursor_execute_KWNAMES "statements", "bindings", "can_cache", "prepare_flags", "explain"
#define Cursor_execute_USAGE "Cursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor"

#define Cursor_execute_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(bindings), PyObject *)); \
  assert(bindings == NULL); \
  assert(__builtin_types_compatible_p(typeof(can_cache), int)); \
  assert(can_cache == 1); \
  assert(__builtin_types_compatible_p(typeof(prepare_flags), int)); \
  assert(prepare_flags == (0)); \
  assert(__builtin_types_compatible_p(typeof(explain), int)); \
  assert(explain == (-1)); \
} while(0)


#define  Cursor_executemany_DOC "Cursor.executemany(statements: str, sequenceofbindings: Iterable[Bindings], *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor\n\n" \
"This method is for when you want to execute the same statements over\n" \
"a sequence of bindings.  Conceptually it does this::\n" \
"\n" \
"  for binding in sequenceofbindings:\n" \
"      cursor.execute(statements, binding)\n" \
"\n" \
"The return is the cursor itself which acts as an iterator.  Your\n" \
"statements can return data.  See :meth:`~Cursor.execute` for more\n" \
"information, and the :ref:`example <example_executemany>`.\n" 

#define Cursor_executemany_KWNAMES "statements", "sequenceofbindings", "can_cache", "prepare_flags", "explain"
#define Cursor_executemany_USAGE "Cursor.executemany(statements: str, sequenceofbindings: Iterable[Bindings], *, can_cache: bool = True, prepare_flags: int = 0, explain: int = -1) -> Cursor"

#define Cursor_executemany_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(sequenceofbindings), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(can_cache), int)); \
  assert(can_cache == 1); \
  assert(__builtin_types_compatible_p(typeof(prepare_flags), int)); \
  assert(prepare_flags == (0)); \
  assert(__builtin_types_compatible_p(typeof(explain), int)); \
  assert(explain == (-1)); \
} while(0)


#define  Cursor_expanded_sql_DOC ":type: str\n" \
"\n" \
"The SQL text with bound parameters expanded.  For example::\n" \
"\n" \
"   execute(\"select ?, ?\", (3, \"three\"))\n" \
"\n" \
"would return::\n" \
"\n" \
"   select 3, 'three'\n" \
"\n" \
"Note that while SQLite supports nulls in strings, their implementation\n" \
"of sqlite3_expanded_sql stops at the first null.\n" \
"\n" \
"You will get :exc:`MemoryError` if SQLite ran out of memory, or if\n" \
"the expanded string would exceed `SQLITE_LIMIT_LENGTH\n" \
"<https://www.sqlite.org/c3ref/c_limit_attached.html>`__.\n" \
"\n" \
"Calls: `sqlite3_expanded_sql <https://sqlite.org/c3ref/expanded_sql.html>`__\n" 

#define  Cursor_fetchall_DOC "Cursor.fetchall() -> list[tuple[SQLiteValue, ...]]\n\n" \
"Returns all remaining result rows as a list.  This method is defined\n" \
"in DBAPI.  See :meth:`get` which does the same thing, but with the least\n" \
"amount of structure to unpack.\n" 

#define  Cursor_fetchone_DOC "Cursor.fetchone() -> Optional[Any]\n\n" \
"Returns the next row of data or None if there are no more rows.\n" 

#define  Cursor_get_DOC ":type: Any\n" \
"\n" \
"Like :meth:`fetchall` but returns the data with the least amount of structure\n" \
"possible.\n" \
"\n" \
".. list-table:: Some examples\n" \
"   :header-rows: 1\n" \
"   :widths: auto\n" \
"\n" \
"   * - Query\n" \
"     - Result\n" \
"   * - select 3\n" \
"     - 3\n" \
"   * - select 3,4\n" \
"     - (3, 4)\n" \
"   * - select 3; select 4\n" \
"     - [3, 4]\n" \
"   * - select 3,4; select 4,5\n" \
"     - [(3, 4), (4, 5)]\n" \
"   * - select 3,4; select 5\n" \
"     - [(3, 4), 5]\n" \
"\n" \
"Row tracers are not called when using this method.\n" 

#define  Cursor_get_connection_DOC "Cursor.get_connection() -> Connection\n\n" \
"Returns the :attr:`connection` this cursor is part of\n" 

#define Cursor_get_connection_OLDNAME "getconnection"
#define Cursor_get_connection_USAGE "Cursor.get_connection() -> Connection"
#define Cursor_get_connection_OLDDOC Cursor_get_connection_USAGE "\n(Old less clear name getconnection)"

#define  Cursor_get_description_DOC "Cursor.get_description() -> tuple[tuple[str, str], ...]\n\n" \
"If you are trying to get information about a table or view,\n" \
"then `pragma table_info <https://sqlite.org/pragma.html#pragma_table_info>`__\n" \
"is better.  If you want to know up front what columns and other\n" \
"details a query does then :func:`apsw.ext.query_info` is useful.\n" \
"\n" \
"Returns a tuple describing each column in the result row.  The\n" \
"return is identical for every row of the results.\n" \
"\n" \
"The information about each column is a tuple of ``(column_name,\n" \
"declared_column_type)``.  The type is what was declared in the\n" \
"``CREATE TABLE`` statement - the value returned in the row will be\n" \
"whatever type you put in for that row and column.\n" \
"\n" \
"See the :ref:`query_info example <example_query_details>`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_column_name <https://sqlite.org/c3ref/column_name.html>`__\n" \
"  * `sqlite3_column_decltype <https://sqlite.org/c3ref/column_decltype.html>`__\n" 

#define Cursor_get_description_OLDNAME "getdescription"
#define Cursor_get_description_USAGE "Cursor.get_description() -> tuple[tuple[str, str], ...]"
#define Cursor_get_description_OLDDOC Cursor_get_description_USAGE "\n(Old less clear name getdescription)"

#define  Cursor_get_exec_trace_DOC "Cursor.get_exec_trace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed :attr:`execution tracer\n" \
"<Cursor.exec_trace>`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define Cursor_get_exec_trace_OLDNAME "getexectrace"
#define Cursor_get_exec_trace_USAGE "Cursor.get_exec_trace() -> Optional[ExecTracer]"
#define Cursor_get_exec_trace_OLDDOC Cursor_get_exec_trace_USAGE "\n(Old less clear name getexectrace)"

#define  Cursor_get_row_trace_DOC "Cursor.get_row_trace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed (via :meth:`~Cursor.set_row_trace`)\n" \
"row tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define Cursor_get_row_trace_OLDNAME "getrowtrace"
#define Cursor_get_row_trace_USAGE "Cursor.get_row_trace() -> Optional[RowTracer]"
#define Cursor_get_row_trace_OLDDOC Cursor_get_row_trace_USAGE "\n(Old less clear name getrowtrace)"

#define  Cursor_has_vdbe_DOC ":type: bool\n" \
"\n" \
"``True`` if the SQL does anything.  Comments have nothing to\n" \
"evaluate, and so are ``False``.\n" 

#define  Cursor_init_DOC "Cursor.__init__(connection: Connection)\n\n" \
"Use :meth:`Connection.cursor` to make a new cursor.\n" 

#define Cursor_init_KWNAMES "connection"
#define Cursor_init_USAGE "Cursor.__init__(connection: Connection)"

#define Cursor_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(connection), Connection *)); \
} while(0)


#define  Cursor_is_explain_DOC ":type: int\n" \
"\n" \
"Returns 0 if executing a normal query, 1 if it is an EXPLAIN query,\n" \
"and 2 if an EXPLAIN QUERY PLAN query.\n" \
"\n" \
"Calls: `sqlite3_stmt_isexplain <https://sqlite.org/c3ref/stmt_isexplain.html>`__\n" 

#define  Cursor_is_readonly_DOC ":type: bool\n" \
"\n" \
"Returns True if the current query does not change the database.\n" \
"\n" \
"Note that called functions, virtual tables etc could make changes though.\n" \
"\n" \
"Calls: `sqlite3_stmt_readonly <https://sqlite.org/c3ref/stmt_readonly.html>`__\n" 

#define  Cursor_iter_DOC "Cursor.__iter__(self: Cursor) -> Cursor\n\n" \
"Cursors are iterators\n" 

#define  Cursor_next_DOC "Cursor.__next__(self: Cursor) -> Any\n\n" \
"Cursors are iterators\n" 

#define  Cursor_row_trace_DOC ":type: Optional[RowTracer]\n" \
"\n" \
"Called with cursor and row being returned.  You can\n" \
"change the data that is returned or cause the row to be skipped\n" \
"altogether.\n" \
"\n" \
"If *callable* is *None* then any existing row tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Connection.row_trace`\n" 

#define Cursor_row_trace_OLDNAME "rowtrace"
#define Cursor_row_trace_USAGE "Cursor.row_trace"
#define Cursor_row_trace_OLDDOC Cursor_row_trace_USAGE "\n(Old less clear name rowtrace)"

#define  Cursor_set_exec_trace_DOC "Cursor.set_exec_trace(callable: Optional[ExecTracer]) -> None\n\n" \
"Sets the :attr:`execution tracer <Cursor.exec_trace>`\n" 

#define Cursor_set_exec_trace_KWNAMES "callable"
#define Cursor_set_exec_trace_USAGE "Cursor.set_exec_trace(callable: Optional[ExecTracer]) -> None"

#define Cursor_set_exec_trace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Cursor_set_exec_trace_OLDNAME "setexectrace"
#define Cursor_set_exec_trace_OLDDOC Cursor_set_exec_trace_USAGE "\n(Old less clear name setexectrace)"

#define  Cursor_set_row_trace_DOC "Cursor.set_row_trace(callable: Optional[RowTracer]) -> None\n\n" \
"Sets the :attr:`row tracer <Cursor.row_trace>`\n" 

#define Cursor_set_row_trace_KWNAMES "callable"
#define Cursor_set_row_trace_USAGE "Cursor.set_row_trace(callable: Optional[RowTracer]) -> None"

#define Cursor_set_row_trace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define Cursor_set_row_trace_OLDNAME "setrowtrace"
#define Cursor_set_row_trace_OLDDOC Cursor_set_row_trace_USAGE "\n(Old less clear name setrowtrace)"

#define  FTS5ExtensionApi_aux_data_DOC ":type: Any\n" \
"\n" \
"You can store an object as `auxiliary data <https://www.sqlite.org/fts5.html#xSetAuxdata>`__\n" \
"which is available across matching rows.  It starts out as :class:`None`.\n" \
"\n" \
"An example use is to do up front calculations once, rather than on\n" \
"every matched row, such as\n" \
":func:`fts5aux.inverse_document_frequency`.\n" 

#define  FTS5ExtensionApi_class_DOC "`Auxiliary functions\n" \
"<https://www.sqlite.org/fts5.html#_auxiliary_functions_>`__  run in\n" \
"the context of a FTS5 search, and can be used for ranking,\n" \
"highlighting, and similar operations.  Auxiliary functions are\n" \
"registered via :meth:`Connection.register_fts5_function`.  This wraps\n" \
"the `auxiliary functions API\n" \
"<https://www.sqlite.org/fts5.html#custom_auxiliary_functions>`__\n" \
"passed as the first parameter to auxiliary functions.\n" \
"\n" \
"See :ref:`the example <example_fts5_auxfunc>`.\n" 

#define  FTS5ExtensionApi_column_count_DOC ":type: int\n" \
"\n" \
"Returns the `number of columns in the table\n" \
"<https://www.sqlite.org/fts5.html#xColumnCount>`__\n" 

#define  FTS5ExtensionApi_column_locale_DOC "FTS5ExtensionApi.column_locale(column: int) -> str | None\n\n" \
"`Retrieves the locale for a column  <https://www.sqlite.org/fts5.html#xColumnLocale>`__ on\n" \
"this row.\n" 

#define FTS5ExtensionApi_column_locale_KWNAMES "column"
#define FTS5ExtensionApi_column_locale_USAGE "FTS5ExtensionApi.column_locale(column: int) -> str | None"

#define FTS5ExtensionApi_column_locale_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(column), int)); \
} while(0)


#define  FTS5ExtensionApi_column_size_DOC "FTS5ExtensionApi.column_size(col: int = -1) -> int\n\n" \
"Returns the `total number of tokens in the current row\n" \
"<https://www.sqlite.org/fts5.html#xColumnSize>`__ for a specific\n" \
"column, or if ``col`` is negative then for all columns.\n" 

#define FTS5ExtensionApi_column_size_KWNAMES "col"
#define FTS5ExtensionApi_column_size_USAGE "FTS5ExtensionApi.column_size(col: int = -1) -> int"

#define FTS5ExtensionApi_column_size_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(col), int)); \
  assert(col == (-1)); \
} while(0)


#define  FTS5ExtensionApi_column_text_DOC "FTS5ExtensionApi.column_text(col: int) -> bytes\n\n" \
"Returns the `utf8 bytes for the column of the current row <https://www.sqlite.org/fts5.html#xColumnText>`__.\n" 

#define FTS5ExtensionApi_column_text_KWNAMES "col"
#define FTS5ExtensionApi_column_text_USAGE "FTS5ExtensionApi.column_text(col: int) -> bytes"

#define FTS5ExtensionApi_column_text_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(col), int)); \
} while(0)


#define  FTS5ExtensionApi_column_total_size_DOC "FTS5ExtensionApi.column_total_size(col: int = -1) -> int\n\n" \
"Returns the `total number of tokens in the table\n" \
"<https://www.sqlite.org/fts5.html#xColumnTotalSize>`__ for a specific\n" \
"column, or if ``col`` is negative then for all columns.\n" 

#define FTS5ExtensionApi_column_total_size_KWNAMES "col"
#define FTS5ExtensionApi_column_total_size_USAGE "FTS5ExtensionApi.column_total_size(col: int = -1) -> int"

#define FTS5ExtensionApi_column_total_size_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(col), int)); \
  assert(col == (-1)); \
} while(0)


#define  FTS5ExtensionApi_inst_count_DOC ":type: int\n" \
"\n" \
"Returns the `number of hits in the current row\n" \
"<https://www.sqlite.org/fts5.html#xInstCount>`__\n" 

#define  FTS5ExtensionApi_inst_tokens_DOC "FTS5ExtensionApi.inst_tokens(inst: int) -> tuple[str, ...] | None\n\n" \
"`Access tokens of hit inst in current row <https://www.sqlite.org/fts5.html#xInstToken>`__.\n" \
"None is returned if the call is not supported.\n" 

#define FTS5ExtensionApi_inst_tokens_KWNAMES "inst"
#define FTS5ExtensionApi_inst_tokens_USAGE "FTS5ExtensionApi.inst_tokens(inst: int) -> tuple[str, ...] | None"

#define FTS5ExtensionApi_inst_tokens_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(inst), int)); \
} while(0)


#define  FTS5ExtensionApi_phrase_column_offsets_DOC "FTS5ExtensionApi.phrase_column_offsets(phrase: int, column: int) -> list[int]\n\n" \
"Returns `token offsets the phrase number occurs in\n" \
"<https://www.sqlite.org/fts5.html#xPhraseFirst>`__  in the specified\n" \
"column.\n" 

#define FTS5ExtensionApi_phrase_column_offsets_KWNAMES "phrase", "column"
#define FTS5ExtensionApi_phrase_column_offsets_USAGE "FTS5ExtensionApi.phrase_column_offsets(phrase: int, column: int) -> list[int]"

#define FTS5ExtensionApi_phrase_column_offsets_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(phrase), int)); \
  assert(__builtin_types_compatible_p(typeof(column), int)); \
} while(0)


#define  FTS5ExtensionApi_phrase_columns_DOC "FTS5ExtensionApi.phrase_columns(phrase: int) -> tuple[int]\n\n" \
"Returns `which columns the phrase number occurs in <https://www.sqlite.org/fts5.html#xPhraseFirstColumn>`__\n" 

#define FTS5ExtensionApi_phrase_columns_KWNAMES "phrase"
#define FTS5ExtensionApi_phrase_columns_USAGE "FTS5ExtensionApi.phrase_columns(phrase: int) -> tuple[int]"

#define FTS5ExtensionApi_phrase_columns_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(phrase), int)); \
} while(0)


#define  FTS5ExtensionApi_phrase_count_DOC ":type: int\n" \
"\n" \
"Returns the `number of phrases in the query\n" \
"<https://www.sqlite.org/fts5.html#xPhraseCount>`__\n" 

#define  FTS5ExtensionApi_phrase_locations_DOC "FTS5ExtensionApi.phrase_locations(phrase: int) -> list[list[int]]\n\n" \
"Returns `which columns and token offsets  the phrase number occurs in\n" \
"<https://www.sqlite.org/fts5.html#xPhraseFirst>`__.\n" \
"\n" \
"The returned list is the same length as the number of columns.  Each\n" \
"member is a list of token offsets in that column, and will be empty\n" \
"if the phrase is not in that column.\n" 

#define FTS5ExtensionApi_phrase_locations_KWNAMES "phrase"
#define FTS5ExtensionApi_phrase_locations_USAGE "FTS5ExtensionApi.phrase_locations(phrase: int) -> list[list[int]]"

#define FTS5ExtensionApi_phrase_locations_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(phrase), int)); \
} while(0)


#define  FTS5ExtensionApi_phrases_DOC ":type: tuple[tuple[str | None, ...], ...]\n" \
"\n" \
"A tuple where each member is a phrase from the query.  Each phrase is a tuple\n" \
"of str (or None when not available) per token of the phrase.\n" \
"\n" \
"This combines the results of `xPhraseCount <https://www.sqlite.org/fts5.html#xPhraseCount>`__,\n" \
"`xPhraseSize <https://www.sqlite.org/fts5.html#xPhraseSize>`__ and\n" \
"`xQueryToken <https://www.sqlite.org/fts5.html#xQueryToken>`__\n" 

#define  FTS5ExtensionApi_query_phrase_DOC "FTS5ExtensionApi.query_phrase(phrase: int, callback: FTS5QueryPhrase, closure: Any) -> None\n\n" \
"Searches the table for the `numbered query <https://www.sqlite.org/fts5.html#xQueryPhrase>`__.\n" \
"The callback takes two parameters - a different :class:`apsw.FTS5ExtensionApi` and closure.\n" \
"\n" \
"An example usage for this method is to see how often the phrases occur in the table.  Setup a\n" \
"tracking counter here, and then in the callback you can update it on each visited row.  This\n" \
"is shown in :ref:`the example <example_fts5_auxfunc>`.\n" 

#define FTS5ExtensionApi_query_phrase_KWNAMES "phrase", "callback", "closure"
#define FTS5ExtensionApi_query_phrase_USAGE "FTS5ExtensionApi.query_phrase(phrase: int, callback: FTS5QueryPhrase, closure: Any) -> None"

#define FTS5ExtensionApi_query_phrase_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(phrase), int)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(closure), PyObject *)); \
} while(0)


#define  FTS5ExtensionApi_row_count_DOC ":type: int\n" \
"\n" \
"Returns the `number of rows in the table\n" \
"<https://www.sqlite.org/fts5.html#xRowCount>`__\n" 

#define  FTS5ExtensionApi_rowid_DOC ":type: int\n" \
"\n" \
"Rowid of the `current row <https://www.sqlite.org/fts5.html#xGetAuxdata>`__\n" 

#define  FTS5ExtensionApi_tokenize_DOC "FTS5ExtensionApi.tokenize(utf8: Buffer, locale: Optional[str], *, include_offsets: bool = True, include_colocated: bool = True) -> list\n\n" \
"`Tokenizes the utf8 <https://www.sqlite.org/fts5.html#xTokenize_v2>`__.  FTS5 sets the reason to ``FTS5_TOKENIZE_AUX``.\n" \
"See :meth:`apsw.FTS5Tokenizer.__call__` for details.\n" 

#define FTS5ExtensionApi_tokenize_KWNAMES "utf8", "locale", "include_offsets", "include_colocated"
#define FTS5ExtensionApi_tokenize_USAGE "FTS5ExtensionApi.tokenize(utf8: Buffer, locale: Optional[str], *, include_offsets: bool = True, include_colocated: bool = True) -> list"

#define FTS5ExtensionApi_tokenize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(utf8), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(locale), const char *)); \
  assert(__builtin_types_compatible_p(typeof(locale_size), Py_ssize_t )); \
  assert(locale == NULL && locale_size == 0); \
  assert(__builtin_types_compatible_p(typeof(include_offsets), int)); \
  assert(include_offsets == 1); \
  assert(__builtin_types_compatible_p(typeof(include_colocated), int)); \
  assert(include_colocated == 1); \
} while(0)


#define  FTS5Tokenizer_args_DOC ":type: tuple[str]\n" \
"\n" \
"The arguments the tokenizer was created with.\n" 

#define  FTS5Tokenizer_call_DOC "FTS5Tokenizer.__call__(utf8: Buffer, flags: int,  locale: Optional[str], *, include_offsets: bool = True, include_colocated: bool = True) -> TokenizerResult\n\n" \
"Does a tokenization, returning a list of the results.  If you have no\n" \
"interest in token offsets or colocated tokens then they can be omitted from\n" \
"the results.\n" \
"\n" \
":param utf8: Input buffer\n" \
":param reason: :data:`Reason <apsw.mapping_fts5_tokenize_reason>` flag\n" \
":param include_offsets: Returned list includes offsets into utf8 for each token\n" \
":param include_colocated: Returned list can include colocated tokens\n" \
"\n" \
"Example outputs\n" \
"---------------\n" \
"\n" \
"Tokenizing ``b\"first place\"`` where ``1st`` has been provided as a\n" \
"colocated token for ``first``.\n" \
"\n" \
"(**Default**) include_offsets **True**, include_colocated **True**\n" \
"\n" \
"  .. code-block:: python\n" \
"\n" \
"        [\n" \
"          (0, 5, \"first\", \"1st\"),\n" \
"          (6, 11, \"place\"),\n" \
"        ]\n" \
"\n" \
"include_offsets **False**, include_colocated **True**\n" \
"\n" \
"  .. code-block:: python\n" \
"\n" \
"        [\n" \
"          (\"first\", \"1st\"),\n" \
"          (\"place\", ),\n" \
"        ]\n" \
"\n" \
"include_offsets **True**, include_colocated **False**\n" \
"\n" \
"  .. code-block:: python\n" \
"\n" \
"        [\n" \
"          (0, 5, \"first\"),\n" \
"          (6, 11, \"place\"),\n" \
"        ]\n" \
"\n" \
"include_offsets **False**, include_colocated **False**\n" \
"\n" \
"  .. code-block:: python\n" \
"\n" \
"        [\n" \
"          \"first\",\n" \
"          \"place\",\n" \
"        ]\n" 

#define FTS5Tokenizer_call_KWNAMES "utf8", "flags", "locale", "include_offsets", "include_colocated"
#define FTS5Tokenizer_call_USAGE "FTS5Tokenizer.__call__(utf8: Buffer, flags: int,  locale: Optional[str], *, include_offsets: bool = True, include_colocated: bool = True) -> TokenizerResult"

#define FTS5Tokenizer_call_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(utf8), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(__builtin_types_compatible_p(typeof(locale), const char *)); \
  assert(__builtin_types_compatible_p(typeof(locale_size), Py_ssize_t )); \
  assert(locale == NULL && locale_size == 0); \
  assert(__builtin_types_compatible_p(typeof(include_offsets), int)); \
  assert(include_offsets == 1); \
  assert(__builtin_types_compatible_p(typeof(include_colocated), int)); \
  assert(include_colocated == 1); \
} while(0)


#define  FTS5Tokenizer_class_DOC "Wraps a registered tokenizer.  Returned by :meth:`Connection.fts5_tokenizer`.\n" 

#define  FTS5Tokenizer_connection_DOC ":type: Connection\n" \
"\n" \
"The :class:`Connection` this tokenizer is registered with.\n" 

#define  FTS5Tokenizer_name_DOC ":type: str\n" \
"\n" \
"Tokenizer name\n" 

#define  IndexInfo_class_DOC "IndexInfo represents the `sqlite3_index_info\n" \
"<https://www.sqlite.org/c3ref/index_info.html>`__ and associated\n" \
"methods used in the :meth:`VTTable.BestIndexObject` method.\n" \
"\n" \
"Naming is identical to the C structure rather than Pythonic.  You can\n" \
"access members directly while needing to use get/set methods for array\n" \
"members.\n" \
"\n" \
"You will get :exc:`InvalidContextError` if you use the object outside of an\n" \
"BestIndex method.\n" \
"\n" \
":meth:`apsw.ext.index_info_to_dict` provides a convenient\n" \
"representation of this object as a :class:`dict`.\n" 

#define  IndexInfo_colUsed_DOC ":type: set[int]\n" \
"\n" \
"(Read-only) Columns used by the statement.  Note that a set is returned, not\n" \
"the underlying integer.\n" 

#define  IndexInfo_distinct_DOC ":type: int\n" \
"\n" \
"(Read-only) How the query planner would like output ordered\n" \
"if the query is using group by or distinct.\n" \
"\n" \
"Calls: `sqlite3_vtab_distinct <https://sqlite.org/c3ref/vtab_distinct.html>`__\n" 

#define  IndexInfo_estimatedCost_DOC ":type: float\n" \
"\n" \
"Estimated cost of using this index\n" 

#define  IndexInfo_estimatedRows_DOC ":type: int\n" \
"\n" \
"Estimated number of rows returned\n" 

#define  IndexInfo_get_aConstraintUsage_argvIndex_DOC "IndexInfo.get_aConstraintUsage_argvIndex(which: int) -> int\n\n" \
"Returns *argvIndex* for *aConstraintUsage[which]*\n" 

#define IndexInfo_get_aConstraintUsage_argvIndex_KWNAMES "which"
#define IndexInfo_get_aConstraintUsage_argvIndex_USAGE "IndexInfo.get_aConstraintUsage_argvIndex(which: int) -> int"

#define IndexInfo_get_aConstraintUsage_argvIndex_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraintUsage_in_DOC "IndexInfo.get_aConstraintUsage_in(which: int) -> bool\n\n" \
"Returns True if the constraint is *in* - eg column in (3, 7, 9)\n" \
"\n" \
"Calls: `sqlite3_vtab_in <https://sqlite.org/c3ref/vtab_in.html>`__\n" 

#define IndexInfo_get_aConstraintUsage_in_KWNAMES "which"
#define IndexInfo_get_aConstraintUsage_in_USAGE "IndexInfo.get_aConstraintUsage_in(which: int) -> bool"

#define IndexInfo_get_aConstraintUsage_in_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraintUsage_omit_DOC "IndexInfo.get_aConstraintUsage_omit(which: int) -> bool\n\n" \
"Returns *omit* for *aConstraintUsage[which]*\n" 

#define IndexInfo_get_aConstraintUsage_omit_KWNAMES "which"
#define IndexInfo_get_aConstraintUsage_omit_USAGE "IndexInfo.get_aConstraintUsage_omit(which: int) -> bool"

#define IndexInfo_get_aConstraintUsage_omit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_collation_DOC "IndexInfo.get_aConstraint_collation(which: int) -> str\n\n" \
"Returns collation name for *aConstraint[which]*\n" \
"\n" \
"Calls: `sqlite3_vtab_collation <https://sqlite.org/c3ref/vtab_collation.html>`__\n" 

#define IndexInfo_get_aConstraint_collation_KWNAMES "which"
#define IndexInfo_get_aConstraint_collation_USAGE "IndexInfo.get_aConstraint_collation(which: int) -> str"

#define IndexInfo_get_aConstraint_collation_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_iColumn_DOC "IndexInfo.get_aConstraint_iColumn(which: int) -> int\n\n" \
"Returns *iColumn* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_iColumn_KWNAMES "which"
#define IndexInfo_get_aConstraint_iColumn_USAGE "IndexInfo.get_aConstraint_iColumn(which: int) -> int"

#define IndexInfo_get_aConstraint_iColumn_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_op_DOC "IndexInfo.get_aConstraint_op(which: int) -> int\n\n" \
"Returns *op* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_op_KWNAMES "which"
#define IndexInfo_get_aConstraint_op_USAGE "IndexInfo.get_aConstraint_op(which: int) -> int"

#define IndexInfo_get_aConstraint_op_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_rhs_DOC "IndexInfo.get_aConstraint_rhs(which: int) -> SQLiteValue\n\n" \
"Returns right hand side value if known, else None.\n" \
"\n" \
"Calls: `sqlite3_vtab_rhs_value <https://sqlite.org/c3ref/vtab_rhs_value.html>`__\n" 

#define IndexInfo_get_aConstraint_rhs_KWNAMES "which"
#define IndexInfo_get_aConstraint_rhs_USAGE "IndexInfo.get_aConstraint_rhs(which: int) -> SQLiteValue"

#define IndexInfo_get_aConstraint_rhs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_usable_DOC "IndexInfo.get_aConstraint_usable(which: int) -> bool\n\n" \
"Returns *usable* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_usable_KWNAMES "which"
#define IndexInfo_get_aConstraint_usable_USAGE "IndexInfo.get_aConstraint_usable(which: int) -> bool"

#define IndexInfo_get_aConstraint_usable_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aOrderBy_desc_DOC "IndexInfo.get_aOrderBy_desc(which: int) -> bool\n\n" \
"Returns *desc* for *aOrderBy[which]*\n" 

#define IndexInfo_get_aOrderBy_desc_KWNAMES "which"
#define IndexInfo_get_aOrderBy_desc_USAGE "IndexInfo.get_aOrderBy_desc(which: int) -> bool"

#define IndexInfo_get_aOrderBy_desc_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aOrderBy_iColumn_DOC "IndexInfo.get_aOrderBy_iColumn(which: int) -> int\n\n" \
"Returns *iColumn* for *aOrderBy[which]*\n" 

#define IndexInfo_get_aOrderBy_iColumn_KWNAMES "which"
#define IndexInfo_get_aOrderBy_iColumn_USAGE "IndexInfo.get_aOrderBy_iColumn(which: int) -> int"

#define IndexInfo_get_aOrderBy_iColumn_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_idxFlags_DOC ":type: int\n" \
"\n" \
"Mask of :attr:`SQLITE_INDEX_SCAN flags <apsw.mapping_virtual_table_scan_flags>`\n" 

#define  IndexInfo_idxNum_DOC ":type: int\n" \
"\n" \
"Number used to identify the index\n" 

#define  IndexInfo_idxStr_DOC ":type: Optional[str]\n" \
"\n" \
"Name used to identify the index\n" 

#define  IndexInfo_nConstraint_DOC ":type: int\n" \
"\n" \
"(Read-only) Number of constraint entries\n" 

#define  IndexInfo_nOrderBy_DOC ":type: int\n" \
"\n" \
"(Read-only) Number of order by  entries\n" 

#define  IndexInfo_orderByConsumed_DOC ":type: bool\n" \
"\n" \
"True if index output is already ordered\n" 

#define  IndexInfo_set_aConstraintUsage_argvIndex_DOC "IndexInfo.set_aConstraintUsage_argvIndex(which: int, argvIndex: int) -> None\n\n" \
"Sets *argvIndex* for *aConstraintUsage[which]*\n" 

#define IndexInfo_set_aConstraintUsage_argvIndex_KWNAMES "which", "argvIndex"
#define IndexInfo_set_aConstraintUsage_argvIndex_USAGE "IndexInfo.set_aConstraintUsage_argvIndex(which: int, argvIndex: int) -> None"

#define IndexInfo_set_aConstraintUsage_argvIndex_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(argvIndex), int)); \
} while(0)


#define  IndexInfo_set_aConstraintUsage_in_DOC "IndexInfo.set_aConstraintUsage_in(which: int, filter_all: bool) -> None\n\n" \
"If *which* is an *in* constraint, and *filter_all* is True then your :meth:`VTCursor.Filter`\n" \
"method will have all of the values at once.\n" \
"\n" \
"Calls: `sqlite3_vtab_in <https://sqlite.org/c3ref/vtab_in.html>`__\n" 

#define IndexInfo_set_aConstraintUsage_in_KWNAMES "which", "filter_all"
#define IndexInfo_set_aConstraintUsage_in_USAGE "IndexInfo.set_aConstraintUsage_in(which: int, filter_all: bool) -> None"

#define IndexInfo_set_aConstraintUsage_in_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(filter_all), int)); \
} while(0)


#define  IndexInfo_set_aConstraintUsage_omit_DOC "IndexInfo.set_aConstraintUsage_omit(which: int, omit: bool) -> None\n\n" \
"Sets *omit* for *aConstraintUsage[which]*\n" 

#define IndexInfo_set_aConstraintUsage_omit_KWNAMES "which", "omit"
#define IndexInfo_set_aConstraintUsage_omit_USAGE "IndexInfo.set_aConstraintUsage_omit(which: int, omit: bool) -> None"

#define IndexInfo_set_aConstraintUsage_omit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(omit), int)); \
} while(0)


#define  PreUpdate_blob_write_DOC ":type: int\n" \
"\n" \
"Writes to blobs show up as `DELETE`, with this having the\n" \
"column number being rewritten.  The value is negative if\n" \
"no blob is being written.\n" \
"\n" \
"Only the old value is available.  To get the new value you have\n" \
"to query the database.\n" \
"\n" \
"Calls: `sqlite3_preupdate_blobwrite <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define  PreUpdate_class_DOC "Provides the details of one update to the\n" \
":meth:`Connection.preupdate_hook` callback.\n" \
"\n" \
".. note::\n" \
"\n" \
"   The object is only valid inside a the callback.\n" \
"   Using it outside the hook gives :exc:`InvalidContextError`.\n" \
"   You should copy all desired information in the callback.\n" 

#define  PreUpdate_connection_DOC ":type: Connection\n" \
"\n" \
"The :class:`Connection` the preupdate is called on.\n" 

#define  PreUpdate_database_name_DOC ":type: str\n" \
"\n" \
"``main``, ``temp``, the name of an attached database.\n" 

#define  PreUpdate_depth_DOC ":type: int\n" \
"\n" \
"0 for direct SQL, 1 for triggers, 2 and so on for triggers\n" \
"firing by a higher level trigger.\n" \
"\n" \
"Calls: `sqlite3_preupdate_depth <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define  PreUpdate_new_DOC ":type: tuple[SQLiteValue, ...] | None\n" \
"\n" \
"Row values for an INSERT, or after an UPDATE.  :class:`None` for\n" \
"DELETE.  See also :attr:`old` and :attr:`update`.\n" \
"\n" \
"Calls: `sqlite3_preupdate_new <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define  PreUpdate_old_DOC ":type: tuple[SQLiteValue, ...] | None\n" \
"\n" \
"Row values for a DELETE, or before an UPDATE. :class:`None` for\n" \
"INSERT.  See also :attr:`new` and :attr:`update`.\n" \
"\n" \
"Calls: `sqlite3_preupdate_old <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define  PreUpdate_op_DOC ":type: str\n" \
"\n" \
"The operation code as a string  ``INSERT``,\n" \
"``DELETE``, or ``UPDATE``.  See :attr:`opcode`\n" \
"for this as a number.\n" 

#define  PreUpdate_opcode_DOC ":type: int\n" \
"\n" \
"The operation code - ``apsw.SQLITE_INSERT``,\n" \
"``apsw.SQLITE_DELETE``, or ``apsw.SQLITE_UPDATE``.\n" \
"See :attr:`op` for this as a string.\n" 

#define  PreUpdate_rowid_DOC ":type: int\n" \
"\n" \
"The affected rowid.\n" 

#define  PreUpdate_rowid_new_DOC ":type: int\n" \
"\n" \
"New rowid if changed via rowid UPDATE.\n" 

#define  PreUpdate_table_name_DOC ":type: str\n" \
"\n" \
"Table name.\n" 

#define  PreUpdate_update_DOC ":type: tuple[SQLiteValue | Literal[no_change], ...] | None\n" \
"\n" \
"For UPDATE compares old and new values, providing the changed value,\n" \
"or :attr:`apsw.no_change` if that column was not changed.\n" \
"\n" \
":class:`None` for INSERT and DELETE.  See also :attr:`old` and\n" \
":attr:`new`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_preupdate_old <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" \
"  * `sqlite3_preupdate_new <https://sqlite.org/c3ref/preupdate_blobwrite.html>`__\n" 

#define  Rebaser_class_DOC "This object wraps a `sqlite3_rebaser\n" \
"<https://www.sqlite.org/session/rebaser.html>`__ object.\n" 

#define  Rebaser_configure_DOC "Rebaser.configure(cr: Buffer) -> None\n\n" \
"Tells the rebaser about conflict resolutions made in an earlier\n" \
":meth:`Changeset.apply`.\n" \
"\n" \
"Calls: `sqlite3rebaser_configure <https://sqlite.org/session/sqlite3rebaser_configure.html>`__\n" 

#define Rebaser_configure_KWNAMES "cr"
#define Rebaser_configure_USAGE "Rebaser.configure(cr: Buffer) -> None"

#define Rebaser_configure_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(cr), PyObject *)); \
} while(0)


#define  Rebaser_init_DOC "Rebaser.__init__()\n\n" \
"Starts a new rebaser.\n" \
"\n" \
"Calls: `sqlite3rebaser_create <https://sqlite.org/session/sqlite3rebaser_create.html>`__\n" 

#define Rebaser_init_KWNAMES NULL
#define Rebaser_init_USAGE "Rebaser.__init__()"

#define Rebaser_init_CHECK do { \
} while(0)


#define  Rebaser_rebase_DOC "Rebaser.rebase(changeset: Buffer) -> bytes\n\n" \
"Produces a new changeset rebased according to :meth:`configure` calls made.\n" \
"\n" \
"Calls: `sqlite3rebaser_rebase <https://sqlite.org/session/sqlite3rebaser_rebase.html>`__\n" 

#define Rebaser_rebase_KWNAMES "changeset"
#define Rebaser_rebase_USAGE "Rebaser.rebase(changeset: Buffer) -> bytes"

#define Rebaser_rebase_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
} while(0)


#define  Rebaser_rebase_stream_DOC "Rebaser.rebase_stream(changeset: SessionStreamInput, output: SessionStreamOutput) -> None\n\n" \
"Produces a new changeset rebased according to :meth:`configure` calls made, using streaming\n" \
"input and output.\n" \
"\n" \
"Calls: `sqlite3rebaser_rebase_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Rebaser_rebase_stream_KWNAMES "changeset", "output"
#define Rebaser_rebase_stream_USAGE "Rebaser.rebase_stream(changeset: SessionStreamInput, output: SessionStreamOutput) -> None"

#define Rebaser_rebase_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(changeset), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  Session_attach_DOC "Session.attach(name: Optional[str] = None) -> None\n\n" \
"Attach to a specific table, or all tables if no name is provided.  The\n" \
"table does not need to exist at the time of the call.  You can call\n" \
"this multiple times.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   :meth:`table_filter`\n" \
"\n" \
"Calls: `sqlite3session_attach <https://sqlite.org/session/sqlite3session_attach.html>`__\n" 

#define Session_attach_KWNAMES "name"
#define Session_attach_USAGE "Session.attach(name: Optional[str] = None) -> None"

#define Session_attach_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(name == 0); \
} while(0)


#define  Session_changeset_DOC "Session.changeset() -> bytes\n\n" \
"Produces a changeset of the session so far.\n" \
"\n" \
"Calls: `sqlite3session_changeset <https://sqlite.org/session/sqlite3session_changeset.html>`__\n" 

#define Session_changeset_KWNAMES NULL
#define Session_changeset_USAGE "Session.changeset() -> bytes"

#define Session_changeset_CHECK do { \
} while(0)


#define  Session_changeset_size_DOC ":type: int\n" \
"\n" \
"Returns upper limit on changeset size, but only if :meth:`Session.config`\n" \
"was used to enable it.  Otherwise it will be zero.\n" \
"\n" \
"Calls: `sqlite3session_changeset_size <https://sqlite.org/session/sqlite3session_changeset_size.html>`__\n" 

#define  Session_changeset_stream_DOC "Session.changeset_stream(output: SessionStreamOutput) -> None\n\n" \
"Produces a changeset of the session so far in a stream\n" \
"\n" \
"Calls: `sqlite3session_changeset_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Session_changeset_stream_KWNAMES "output"
#define Session_changeset_stream_USAGE "Session.changeset_stream(output: SessionStreamOutput) -> None"

#define Session_changeset_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  Session_class_DOC "This object wraps a `sqlite3_session\n" \
"<https://www.sqlite.org/session/session.html>`__ object.\n" 

#define  Session_close_DOC "Session.close() -> None\n\n" \
"Ends the session object.  APSW ensures that all\n" \
"Session objects are closed before the database is closed\n" \
"so there is no need to manually call this.\n" \
"\n" \
"Calls: `sqlite3session_delete <https://sqlite.org/session/sqlite3session_delete.html>`__\n" 

#define Session_close_KWNAMES NULL
#define Session_close_USAGE "Session.close() -> None"

#define Session_close_CHECK do { \
} while(0)


#define  Session_config_DOC "Session.config(op: int, *args: Any) -> Any\n\n" \
"Set or get `configuration values <https://www.sqlite.org/session/c_session_objconfig_rowid.html>`__\n" \
"\n" \
"For example :code:`session.config(apsw.SQLITE_SESSION_OBJCONFIG_SIZE, -1)` tells you\n" \
"if size information is enabled.\n" \
"\n" \
"Calls: `sqlite3session_object_config <https://sqlite.org/session/sqlite3session_object_config.html>`__\n" 

#define  Session_diff_DOC "Session.diff(from_schema: str, table: str) -> None\n\n" \
"Loads the changes necessary to update the named ``table`` in the attached database\n" \
"``from_schema`` to match the same named table in the database this session is\n" \
"attached to.\n" \
"\n" \
"See the :ref:`example <example_session_diff>`.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You must use :meth:`attach` (or use :meth:`table_filter`) to attach to\n" \
"  the table before running this method otherwise nothing is recorded.\n" \
"\n" \
"Calls: `sqlite3session_diff <https://sqlite.org/session/sqlite3session_diff.html>`__\n" 

#define Session_diff_KWNAMES "from_schema", "table"
#define Session_diff_USAGE "Session.diff(from_schema: str, table: str) -> None"

#define Session_diff_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(from_schema), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table), const char *)); \
} while(0)


#define  Session_enabled_DOC ":type: bool\n" \
"\n" \
"Get or change if this session is recording changes.  Disabling only\n" \
"stops recording rows not already part of the changeset.\n" \
"\n" \
"Calls: `sqlite3session_enable <https://sqlite.org/session/sqlite3session_enable.html>`__\n" 

#define  Session_indirect_DOC ":type: bool\n" \
"\n" \
"Get or change if this session is in indirect mode\n" \
"\n" \
"Calls: `sqlite3session_indirect <https://sqlite.org/session/sqlite3session_indirect.html>`__\n" 

#define  Session_init_DOC "Session.__init__(db: Connection, schema: str)\n\n" \
"Starts a new session.\n" \
"\n" \
":param connection: Which database to operate on\n" \
":param schema: `main`, `temp`, the name in `ATTACH <https://sqlite.org/lang_attach.html>`__\n" \
"\n" \
"Calls: `sqlite3session_create <https://sqlite.org/session/sqlite3session_create.html>`__\n" 

#define Session_init_KWNAMES "db", "schema"
#define Session_init_USAGE "Session.__init__(db: Connection, schema: str)"

#define Session_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(db), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
} while(0)


#define  Session_is_empty_DOC ":type: bool\n" \
"\n" \
"True if no changes have been recorded.\n" \
"\n" \
"Calls: `sqlite3session_isempty <https://sqlite.org/session/sqlite3session_isempty.html>`__\n" 

#define  Session_memory_used_DOC ":type: int\n" \
"\n" \
"How many bytes of memory have been used to record session changes.\n" \
"\n" \
"Calls: `sqlite3session_memory_used <https://sqlite.org/session/sqlite3session_memory_used.html>`__\n" 

#define  Session_patchset_DOC "Session.patchset() -> bytes\n\n" \
"Produces a patchset of the session so far.  Patchsets do not include\n" \
"before values of changes, making them smaller, but also harder to detect\n" \
"conflicts.\n" \
"\n" \
"Calls: `sqlite3session_patchset <https://sqlite.org/session/sqlite3session_patchset.html>`__\n" 

#define Session_patchset_KWNAMES NULL
#define Session_patchset_USAGE "Session.patchset() -> bytes"

#define Session_patchset_CHECK do { \
} while(0)


#define  Session_patchset_stream_DOC "Session.patchset_stream(output: SessionStreamOutput) -> None\n\n" \
"Produces a patchset of the session so far in a stream\n" \
"\n" \
"Calls: `sqlite3session_patchset_strm <https://sqlite.org/session/sqlite3changegroup_add_strm.html>`__\n" 

#define Session_patchset_stream_KWNAMES "output"
#define Session_patchset_stream_USAGE "Session.patchset_stream(output: SessionStreamOutput) -> None"

#define Session_patchset_stream_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(output), PyObject *)); \
} while(0)


#define  Session_table_filter_DOC "Session.table_filter(callback: Callable[[str], bool]) -> None\n\n" \
"Register a callback that says if changes to the named table should be\n" \
"recorded.  If your callback has an exception then ``False`` is\n" \
"returned.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`attach`\n" \
"\n" \
"Calls: `sqlite3session_table_filter <https://sqlite.org/session/sqlite3session_table_filter.html>`__\n" 

#define Session_table_filter_KWNAMES "callback"
#define Session_table_filter_USAGE "Session.table_filter(callback: Callable[[str], bool]) -> None"

#define Session_table_filter_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
} while(0)


#define  TableChange_class_DOC "Represents a `changed row\n" \
"<https://sqlite.org/session/changeset_iter.html>`__.  They come from\n" \
":meth:`changeset iteration <Changeset.iter>` and from the\n" \
":meth:`conflict handler in apply <Changeset.apply>`.\n" \
"\n" \
"A TableChange is only valid when your conflict handler is active, or\n" \
"has just been provided by a changeset iterator.  It goes out of scope\n" \
"after your conflict handler returns, or the iterator moves to the next\n" \
"entry.  You will get :exc:`~apsw.InvalidContextError` if you try to\n" \
"access fields when out of scope.  This means you can't save\n" \
"TableChanges for later, and need to copy out any information you need.\n" 

#define  TableChange_column_count_DOC ":type: int\n" \
"\n" \
" Number of columns in the affected table\n" 

#define  TableChange_conflict_DOC ":type: tuple[SQLiteValue, ...] | None\n" \
"\n" \
":class:`None` if not applicable (not in a conflict).  Otherwise a\n" \
"tuple of values for the conflicting row.\n" \
"\n" \
"Calls: `sqlite3changeset_conflict <https://sqlite.org/session/sqlite3changeset_conflict.html>`__\n" 

#define  TableChange_fk_conflicts_DOC ":type: int | None\n" \
"\n" \
"The number of known foreign key conflicts, or :class:`None` if not in a\n" \
"conflict handler.\n" \
"\n" \
"Calls: `sqlite3changeset_fk_conflicts <https://sqlite.org/session/sqlite3changeset_fk_conflicts.html>`__\n" 

#define  TableChange_indirect_DOC ":type: bool\n" \
"\n" \
"``True`` if this is an `indirect <https://sqlite.org/session/sqlite3session_indirect.html>`__\n" \
"change - for example made by triggers or foreign keys.\n" 

#define  TableChange_name_DOC ":type: str\n" \
"\n" \
" Name of the affected table\n" 

#define  TableChange_new_DOC ":type: tuple[SQLiteValue | Literal[no_change], ...] | None\n" \
"\n" \
":class:`None` if not applicable (like a DELETE).  Otherwise a\n" \
"tuple of the new values for the row, with :attr:`apsw.no_change`\n" \
"if no value was provided for that column.\n" \
"\n" \
"Calls: `sqlite3changeset_new <https://sqlite.org/session/sqlite3changeset_new.html>`__\n" 

#define  TableChange_old_DOC ":type: tuple[SQLiteValue | Literal[no_change], ...] | None\n" \
"\n" \
":class:`None` if not applicable (like an INSERT).  Otherwise a tuple\n" \
"of the old values for the row before this change, with\n" \
":attr:`apsw.no_change` if no value was provided for that column,\n" \
"\n" \
"Calls: `sqlite3changeset_old <https://sqlite.org/session/sqlite3changeset_old.html>`__\n" 

#define  TableChange_op_DOC ":type: str\n" \
"\n" \
" The operation code as a string  ``INSERT``,\n" \
" ``DELETE``, or ``UPDATE``.  See :attr:`opcode`\n" \
" for this as a number.\n" 

#define  TableChange_opcode_DOC ":type: int\n" \
"\n" \
" The operation code - ``apsw.SQLITE_INSERT``,\n" \
" ``apsw.SQLITE_DELETE``, or ``apsw.SQLITE_UPDATE``.\n" \
" See :attr:`op` for this as a string.\n" 

#define  TableChange_pk_columns_DOC ":type: set[int]\n" \
"\n" \
"Which columns make up the primary key for this table\n" \
"\n" \
"Calls: `sqlite3changeset_pk <https://sqlite.org/session/sqlite3changeset_pk.html>`__\n" 

#define  URIFilename_class_DOC "SQLite packs `uri parameters\n" \
"<https://sqlite.org/uri.html>`__ and the filename together   This class\n" \
"encapsulates that packing.  The :ref:`example <example_vfs>` shows\n" \
"usage of this class.\n" \
"\n" \
"Your :meth:`VFS.xOpen` method will generally be passed one of\n" \
"these instead of a string as the filename if the URI flag was used\n" \
"or the main database flag is set.\n" \
"\n" \
"You can safely pass it on to the :class:`VFSFile` constructor\n" \
"which knows how to get the name back out.  The URIFilename is\n" \
"only valid for the duration of the xOpen call.  If you save\n" \
"and use the object later you will get an exception.\n" 

#define  URIFilename_filename_DOC "URIFilename.filename() -> str\n\n" \
"Returns the filename.\n" 

#define  URIFilename_parameters_DOC ":type: tuple[str, ...]\n" \
"\n" \
"A tuple of the parameter names present.\n" \
"\n" \
"Calls: `sqlite3_uri_key <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define  URIFilename_uri_boolean_DOC "URIFilename.uri_boolean(name: str, default: bool) -> bool\n\n" \
"Returns the boolean value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_boolean <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_boolean_KWNAMES "name", "default_"
#define URIFilename_uri_boolean_USAGE "URIFilename.uri_boolean(name: str, default: bool) -> bool"

#define URIFilename_uri_boolean_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), int)); \
} while(0)


#define  URIFilename_uri_int_DOC "URIFilename.uri_int(name: str, default: int) -> int\n\n" \
"Returns the integer value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_int64 <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_int_KWNAMES "name", "default_"
#define URIFilename_uri_int_USAGE "URIFilename.uri_int(name: str, default: int) -> int"

#define URIFilename_uri_int_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), long long)); \
} while(0)


#define  URIFilename_uri_parameter_DOC "URIFilename.uri_parameter(name: str) -> Optional[str]\n\n" \
"Returns the value of parameter `name` or None.\n" \
"\n" \
"Calls: `sqlite3_uri_parameter <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_parameter_KWNAMES "name"
#define URIFilename_uri_parameter_USAGE "URIFilename.uri_parameter(name: str) -> Optional[str]"

#define URIFilename_uri_parameter_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFSFcntlPragma_class_DOC "A helper class to work with `SQLITE_FCNTL_PRAGMA\n" \
"<https://sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma>`__\n" \
"in :meth:`VFSFile.xFileControl`. The :ref:`example <example_vfs>`\n" \
"shows usage of this class.\n" \
"\n" \
"It is only valid while in :meth:`VFSFile.xFileControl`, and using\n" \
"outside of that will result in memory corruption and crashes.\n" 

#define  VFSFcntlPragma_init_DOC "VFSFcntlPragma.__init__(pointer: int)\n\n" \
"The pointer must be what your xFileControl method received.\n" 

#define VFSFcntlPragma_init_KWNAMES "pointer"
#define VFSFcntlPragma_init_USAGE "VFSFcntlPragma.__init__(pointer: int)"

#define VFSFcntlPragma_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  VFSFcntlPragma_name_DOC ":type: str\n" \
"\n" \
"The name of the pragma\n" 

#define  VFSFcntlPragma_result_DOC ":type: str | None\n" \
"\n" \
"The first element which becomes the result or error message\n" 

#define  VFSFcntlPragma_value_DOC ":type: str | None\n" \
"\n" \
"The value for the pragma, if provided else None,\n" 

#define  VFSFile_class_DOC "Wraps access to a file.  You only need to derive from this class\n" \
"if you want the file object returned from :meth:`VFS.xOpen` to\n" \
"inherit from an existing VFS implementation.\n" 

#define  VFSFile_excepthook_DOC "VFSFile.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[types.TracebackType]) ->None\n\n" \
"Called when there has been an exception in a :class:`VFSFile`\n" \
"routine, and it can't be reported to the caller as usual.\n" \
"\n" \
"The default implementation passes the exception information\n" \
"to sqlite3_log, and the first non-error of\n" \
":func:`sys.unraisablehook` and :func:`sys.excepthook`, falling back to\n" \
"`PyErr_Display`.\n" 

#define  VFSFile_init_DOC "VFSFile.__init__(vfs: str, filename: str | URIFilename | None, flags: list[int,int])\n\n" \
":param vfs: The vfs you want to inherit behaviour from.  You can\n" \
"   use an empty string ``\"\"`` to inherit from the default vfs.\n" \
":param name: The name of the file being opened.  May be an instance of :class:`URIFilename`.\n" \
":param flags: A two item list ``[inflags, outflags]`` as detailed in :meth:`VFS.xOpen`.\n" \
"\n" \
":raises ValueError: If the named VFS is not registered.\n" \
"\n" \
".. note::\n" \
"\n" \
"  If the VFS that you inherit from supports :ref:`write ahead\n" \
"  logging <wal>` then your :class:`VFSFile` will also support the\n" \
"  xShm methods necessary to implement wal.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`VFS.xOpen`\n" 

#define VFSFile_init_KWNAMES "vfs", "filename", "flags"
#define VFSFile_init_USAGE "VFSFile.__init__(vfs: str, filename: str | URIFilename | None, flags: list[int,int])"

#define VFSFile_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(__builtin_types_compatible_p(typeof(filename), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFSFile_xCheckReservedLock_DOC "VFSFile.xCheckReservedLock() -> bool\n\n" \
"Returns True if any database connection (in this or another process)\n" \
"has a lock other than `SQLITE_LOCK_NONE or SQLITE_LOCK_SHARED\n" \
"<https://sqlite.org/c3ref/c_lock_exclusive.html>`_.\n" 

#define  VFSFile_xClose_DOC "VFSFile.xClose() -> None\n\n" \
"Close the database. Note that even if you return an error you should\n" \
"still close the file.  It is safe to call this method multiple\n" \
"times.\n" 

#define  VFSFile_xDeviceCharacteristics_DOC "VFSFile.xDeviceCharacteristics() -> int\n\n" \
"Return `I/O capabilities\n" \
"<https://sqlite.org/c3ref/c_iocap_atomic.html>`_ (bitwise or of\n" \
"appropriate values). If you do not implement the function or have an\n" \
"error then 0 (the SQLite default) is returned.\n" 

#define  VFSFile_xFileControl_DOC "VFSFile.xFileControl(op: int, ptr: int) -> bool\n\n" \
"Receives `file control\n" \
" <https://sqlite.org/c3ref/file_control.html>`_ request typically\n" \
" issued by :meth:`Connection.file_control`.  See\n" \
" :meth:`Connection.file_control` for an example of how to pass a\n" \
" Python object to this routine.\n" \
"\n" \
" :param op: A numeric code.  Codes below 100 are reserved for SQLite\n" \
"   internal use.\n" \
" :param ptr: An integer corresponding to a pointer at the C level.\n" \
"\n" \
" :returns: A boolean indicating if the op was understood\n" \
"\n" \
" Ensure you pass any unrecognised codes through to your super class.\n" \
" For example::\n" \
"\n" \
"     def xFileControl(self, op: int, ptr: int) -> bool:\n" \
"         if op == 1027:\n" \
"             process_quick(ptr)\n" \
"         elif op == 1028:\n" \
"             obj=ctypes.py_object.from_address(ptr).value\n" \
"         else:\n" \
"             # this ensures superclass implementation is called\n" \
"             return super().xFileControl(op, ptr)\n" \
"        # we understood the op\n" \
"        return True\n" \
"\n" \
".. note::\n" \
"\n" \
"  `SQLITE_FCNTL_VFSNAME\n" \
"  <https://sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlvfsname>`__\n" \
"  is automatically handled for you dealing with the necessary memory allocation\n" \
"  and listing all the VFS if you are inheriting.  It includes the fully qualified\n" \
"  class name for this object.\n" 

#define VFSFile_xFileControl_KWNAMES "op", "ptr"
#define VFSFile_xFileControl_USAGE "VFSFile.xFileControl(op: int, ptr: int) -> bool"

#define VFSFile_xFileControl_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(ptr), void *)); \
} while(0)


#define  VFSFile_xFileSize_DOC "VFSFile.xFileSize() -> int\n\n" \
"Return the size of the file in bytes.\n" 

#define  VFSFile_xLock_DOC "VFSFile.xLock(level: int) -> None\n\n" \
"Increase the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants. If you can't increase the lock level because\n" \
"someone else has locked it, then raise :exc:`BusyError`.\n" 

#define VFSFile_xLock_KWNAMES "level"
#define VFSFile_xLock_USAGE "VFSFile.xLock(level: int) -> None"

#define VFSFile_xLock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xRead_DOC "VFSFile.xRead(amount: int, offset: int) -> bytes\n\n" \
"Read the specified *amount* of data starting at *offset*. You\n" \
"should make every effort to read all the data requested, or return\n" \
"an error. If you have the file open for non-blocking I/O or if\n" \
"signals happen then it is possible for the underlying operating\n" \
"system to do a partial read. You will need to request the\n" \
"remaining data. Except for empty files SQLite considers short\n" \
"reads to be a fatal error.\n" \
"\n" \
":param amount: Number of bytes to read\n" \
":param offset: Where to start reading.\n" 

#define VFSFile_xRead_KWNAMES "amount", "offset"
#define VFSFile_xRead_USAGE "VFSFile.xRead(amount: int, offset: int) -> bytes"

#define VFSFile_xRead_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFSFile_xSectorSize_DOC "VFSFile.xSectorSize() -> int\n\n" \
"Return the native underlying sector size. SQLite uses the value\n" \
"returned in determining the default database page size. If you do\n" \
"not implement the function or have an error then 4096 (the SQLite\n" \
"default) is returned.\n" 

#define  VFSFile_xSync_DOC "VFSFile.xSync(flags: int) -> None\n\n" \
"Ensure data is on the disk platters (ie could survive a power\n" \
"failure immediately after the call returns) with the `sync flags\n" \
"<https://sqlite.org/c3ref/c_sync_dataonly.html>`_ detailing what\n" \
"needs to be synced.\n" 

#define VFSFile_xSync_KWNAMES "flags"
#define VFSFile_xSync_USAGE "VFSFile.xSync(flags: int) -> None"

#define VFSFile_xSync_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFSFile_xTruncate_DOC "VFSFile.xTruncate(newsize: int) -> None\n\n" \
"Set the file length to *newsize* (which may be more or less than the\n" \
"current length).\n" 

#define VFSFile_xTruncate_KWNAMES "newsize"
#define VFSFile_xTruncate_USAGE "VFSFile.xTruncate(newsize: int) -> None"

#define VFSFile_xTruncate_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(newsize), long long)); \
} while(0)


#define  VFSFile_xUnlock_DOC "VFSFile.xUnlock(level: int) -> None\n\n" \
"Decrease the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants.\n" 

#define VFSFile_xUnlock_KWNAMES "level"
#define VFSFile_xUnlock_USAGE "VFSFile.xUnlock(level: int) -> None"

#define VFSFile_xUnlock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xWrite_DOC "VFSFile.xWrite(data: Buffer, offset: int) -> None\n\n" \
"Write the *data* starting at absolute *offset*. You must write all the data\n" \
"requested, or return an error. If you have the file open for\n" \
"non-blocking I/O or if signals happen then it is possible for the\n" \
"underlying operating system to do a partial write. You will need to\n" \
"write the remaining data.\n" \
"\n" \
":param offset: Where to start writing.\n" 

#define VFSFile_xWrite_KWNAMES "data", "offset"
#define VFSFile_xWrite_USAGE "VFSFile.xWrite(data: Buffer, offset: int) -> None"

#define VFSFile_xWrite_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFS_class_DOC "Provides operating system access.  You can get an overview in the\n" \
"`SQLite documentation <https://sqlite.org/c3ref/vfs.html>`_.  To\n" \
"create a VFS your Python class must inherit from :class:`VFS`.\n" 

#define  VFS_excepthook_DOC "VFS.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[types.TracebackType]) -> Any\n\n" \
"Called when there has been an exception in a :class:`VFS` routine,\n" \
"and it can't be reported to the caller as usual.\n" \
"\n" \
"The default implementation passes the exception information\n" \
"to sqlite3_log, and the first non-error of\n" \
":func:`sys.unraisablehook` and :func:`sys.excepthook`, falling back to\n" \
"`PyErr_Display`.\n" 

#define  VFS_init_DOC "VFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024, *, iVersion: int = 3, exclude: Optional[set[str]] = None)\n\n" \
":param name: The name to register this vfs under.  If the name\n" \
"    already exists then this vfs will replace the prior one of the\n" \
"    same name.  Use :meth:`apsw.vfs_names` to get a list of\n" \
"    registered vfs names.\n" \
"\n" \
":param base: If you would like to inherit behaviour from an already registered vfs then give\n" \
"    their name.  To inherit from the default vfs, use a zero\n" \
"    length string ``\"\"`` as the name.\n" \
"\n" \
":param makedefault: If true then this vfs will be registered as the default, and will be\n" \
"    used by any opens that don't specify a vfs.\n" \
"\n" \
":param maxpathname: The maximum length of database name in bytes when\n" \
"    represented in UTF-8.  If a pathname is passed in longer than\n" \
"    this value then SQLite will not`be able to open it.  If you are\n" \
"    using a base, then a value of zero will use the value from base.\n" \
"\n" \
":param iVersion: Version number for the `sqlite3_vfs <https://sqlite.org/c3ref/vfs.html>`__\n" \
"    structure.\n" \
"\n" \
":param exclude: A set of strings, naming the methods that will be filled in with ``NULL`` in the `sqlite3_vfs\n" \
"    <https://sqlite.org/c3ref/vfs.html>`__  structure to indicate to SQLite that they are\n" \
"    not supported.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_register <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define VFS_init_KWNAMES "name", "base", "makedefault", "maxpathname", "iVersion", "exclude"
#define VFS_init_USAGE "VFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024, *, iVersion: int = 3, exclude: Optional[set[str]] = None)"

#define VFS_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(base), const char *)); \
  assert(base == 0); \
  assert(__builtin_types_compatible_p(typeof(makedefault), int)); \
  assert(makedefault == 0); \
  assert(__builtin_types_compatible_p(typeof(maxpathname), int)); \
  assert(maxpathname == (1024)); \
  assert(__builtin_types_compatible_p(typeof(iVersion), int)); \
  assert(iVersion == (3)); \
  assert(__builtin_types_compatible_p(typeof(exclude), PyObject *)); \
  assert(exclude == NULL); \
} while(0)


#define  VFS_unregister_DOC "VFS.unregister() -> None\n\n" \
"Unregisters the VFS making it unavailable to future database\n" \
"opens. You do not need to call this as the VFS is automatically\n" \
"unregistered by when the VFS has no more references or open\n" \
"databases using it. It is however useful to call if you have made\n" \
"your VFS be the default and wish to immediately make it be\n" \
"unavailable. It is safe to call this routine multiple times.\n" \
"\n" \
"Calls: `sqlite3_vfs_unregister <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define  VFS_xAccess_DOC "VFS.xAccess(pathname: str, flags: int) -> bool\n\n" \
"SQLite wants to check access permissions.  Return True or False\n" \
"accordingly.\n" \
"\n" \
":param pathname: File or directory to check\n" \
":param flags: One of the `access flags <https://sqlite.org/c3ref/c_access_exists.html>`_\n" 

#define VFS_xAccess_KWNAMES "pathname", "flags"
#define VFS_xAccess_USAGE "VFS.xAccess(pathname: str, flags: int) -> bool"

#define VFS_xAccess_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(pathname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFS_xCurrentTime_DOC "VFS.xCurrentTime()  -> float\n\n" \
"Return the `Julian Day Number\n" \
"<https://en.wikipedia.org/wiki/Julian_day>`_ as a floating point\n" \
"number where the integer portion is the day and the fractional part\n" \
"is the time.\n" 

#define  VFS_xCurrentTimeInt64_DOC "VFS.xCurrentTimeInt64()  -> int\n\n" \
"Returns as an integer the `Julian Day Number\n" \
"<https://en.wikipedia.org/wiki/Julian_day>`__ multiplied by 86400000\n" \
"(the number of milliseconds in a 24-hour day).\n" 

#define  VFS_xDelete_DOC "VFS.xDelete(filename: str, syncdir: bool) -> None\n\n" \
"Delete the named file. If the file is missing then raise an\n" \
":exc:`IOError` exception with extendedresult\n" \
"*SQLITE_IOERR_DELETE_NOENT*\n" \
"\n" \
":param filename: File to delete\n" \
"\n" \
":param syncdir: If True then the directory should be synced\n" \
"  ensuring that the file deletion has been recorded on the disk\n" \
"  platters.  ie if there was an immediate power failure after this\n" \
"  call returns, on a reboot the file would still be deleted.\n" 

#define VFS_xDelete_KWNAMES "filename", "syncdir"
#define VFS_xDelete_USAGE "VFS.xDelete(filename: str, syncdir: bool) -> None"

#define VFS_xDelete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(syncdir), int)); \
} while(0)


#define  VFS_xDlClose_DOC "VFS.xDlClose(handle: int) -> None\n\n" \
"Close and unload the library corresponding to the handle you\n" \
"returned from :meth:`~VFS.xDlOpen`.  You can use ctypes to do\n" \
"this::\n" \
"\n" \
"  def xDlClose(handle: int):\n" \
"     # Note leading underscore in _ctypes\n" \
"     _ctypes.dlclose(handle)       # Linux/Mac/Unix\n" \
"     _ctypes.FreeLibrary(handle)   # Windows\n" 

#define VFS_xDlClose_KWNAMES "handle"
#define VFS_xDlClose_USAGE "VFS.xDlClose(handle: int) -> None"

#define VFS_xDlClose_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
} while(0)


#define  VFS_xDlError_DOC "VFS.xDlError() -> str\n\n" \
"Return an error string describing the last error of\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym` (ie they returned\n" \
"zero/NULL). If you do not supply this routine then SQLite provides\n" \
"a generic message. To implement this method, catch exceptions in\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym`, turn them into\n" \
"strings, save them, and return them in this routine.  If you have\n" \
"an error in this routine or return None then SQLite's generic\n" \
"message will be used.\n" 

#define  VFS_xDlOpen_DOC "VFS.xDlOpen(filename: str) -> int\n\n" \
"Load the shared library. You should return a number which will be\n" \
"treated as a void pointer at the C level. On error you should\n" \
"return 0 (NULL). The number is passed as is to\n" \
":meth:`~VFS.xDlSym`/:meth:`~VFS.xDlClose` so it can represent\n" \
"anything that is convenient for you (eg an index into an\n" \
"array). You can use ctypes to load a library::\n" \
"\n" \
"  def xDlOpen(name: str):\n" \
"     return ctypes.cdll.LoadLibrary(name)._handle\n" 

#define VFS_xDlOpen_KWNAMES "filename"
#define VFS_xDlOpen_USAGE "VFS.xDlOpen(filename: str) -> int"

#define VFS_xDlOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
} while(0)


#define  VFS_xDlSym_DOC "VFS.xDlSym(handle: int, symbol: str) -> int\n\n" \
"Returns the address of the named symbol which will be called by\n" \
"SQLite. On error you should return 0 (NULL). You can use ctypes::\n" \
"\n" \
"  def xDlSym(ptr: int, name: str):\n" \
"     return _ctypes.dlsym (ptr, name)  # Linux/Unix/Mac etc (note leading underscore)\n" \
"     return ctypes.win32.kernel32.GetProcAddress (ptr, name)  # Windows\n" \
"\n" \
":param handle: The value returned from an earlier :meth:`~VFS.xDlOpen` call\n" \
":param symbol: A string\n" 

#define VFS_xDlSym_KWNAMES "handle", "symbol"
#define VFS_xDlSym_USAGE "VFS.xDlSym(handle: int, symbol: str) -> int"

#define VFS_xDlSym_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
  assert(__builtin_types_compatible_p(typeof(symbol), const char *)); \
} while(0)


#define  VFS_xFullPathname_DOC "VFS.xFullPathname(name: str) -> str\n\n" \
"Return the absolute pathname for name.  You can use ``os.path.abspath`` to do this.\n" 

#define VFS_xFullPathname_KWNAMES "name"
#define VFS_xFullPathname_USAGE "VFS.xFullPathname(name: str) -> str"

#define VFS_xFullPathname_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xGetLastError_DOC "VFS.xGetLastError() -> tuple[int, str]\n\n" \
"Return an integer error code and (optional) text describing\n" \
"the last error code and message that happened in this thread.\n" 

#define  VFS_xGetSystemCall_DOC "VFS.xGetSystemCall(name: str) -> Optional[int]\n\n" \
"Returns a pointer for the current method implementing the named\n" \
"system call.  Return None if the call does not exist.\n" 

#define VFS_xGetSystemCall_KWNAMES "name"
#define VFS_xGetSystemCall_USAGE "VFS.xGetSystemCall(name: str) -> Optional[int]"

#define VFS_xGetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xNextSystemCall_DOC "VFS.xNextSystemCall(name: Optional[str]) -> Optional[str]\n\n" \
"This method is repeatedly called to iterate over all of the system\n" \
"calls in the vfs.  When called with None you should return the\n" \
"name of the first system call.  In subsequent calls return the\n" \
"name after the one passed in.  If name is the last system call\n" \
"then return None.\n" 

#define VFS_xNextSystemCall_KWNAMES "name"
#define VFS_xNextSystemCall_USAGE "VFS.xNextSystemCall(name: Optional[str]) -> Optional[str]"

#define VFS_xNextSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xOpen_DOC "VFS.xOpen(name: Optional[str | URIFilename], flags: list[int,int]) -> VFSFile\n\n" \
"This method should return a new file object based on name.  You\n" \
"can return a :class:`VFSFile` from a completely different VFS.\n" \
"\n" \
":param name: File to open.  Note that *name* may be *None* in which\n" \
"    case you should open a temporary file with a name of your\n" \
"    choosing.  May be an instance of :class:`URIFilename`.\n" \
"\n" \
":param flags: A list of two integers ``[inputflags,\n" \
"  outputflags]``.  Each integer is one or more of the `open flags\n" \
"  <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ binary orred\n" \
"  together.  The ``inputflags`` tells you what SQLite wants.  For\n" \
"  example *SQLITE_OPEN_DELETEONCLOSE* means the file should\n" \
"  be automatically deleted when closed.  The ``outputflags``\n" \
"  describes how you actually did open the file.  For example if you\n" \
"  opened it read only then *SQLITE_OPEN_READONLY* should be\n" \
"  set.\n" 

#define VFS_xOpen_KWNAMES "name", "flags"
#define VFS_xOpen_USAGE "VFS.xOpen(name: Optional[str | URIFilename], flags: list[int,int]) -> VFSFile"

#define VFS_xOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFS_xRandomness_DOC "VFS.xRandomness(numbytes: int) -> bytes\n\n" \
"This method is called once on the default VFS when SQLite needs to\n" \
"seed the random number generator.  You can return less than the\n" \
"number of bytes requested including None. If you return more then\n" \
"the surplus is ignored.\n" 

#define VFS_xRandomness_KWNAMES "numbytes"
#define VFS_xRandomness_USAGE "VFS.xRandomness(numbytes: int) -> bytes"

#define VFS_xRandomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(numbytes), int)); \
} while(0)


#define  VFS_xSetSystemCall_DOC "VFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool\n\n" \
"Change a system call used by the VFS.  This is useful for testing\n" \
"and some other scenarios such as sandboxing.\n" \
"\n" \
":param name: The string name of the system call\n" \
"\n" \
":param pointer: A pointer provided as an int.  There is no\n" \
"  reference counting or other memory tracking of the pointer.  If\n" \
"  you provide one you need to ensure it is around for the lifetime\n" \
"  of this and any other related VFS.\n" \
"\n" \
"Raise an exception to return an error.  If the system call does\n" \
"not exist then raise :exc:`NotFoundError`.\n" \
"\n" \
"If `name` is None, then all systemcalls are reset to their defaults.\n" \
"\n" \
":returns: True if the system call was set.  False if the system\n" \
"  call is not known.\n" 

#define VFS_xSetSystemCall_KWNAMES "name", "pointer"
#define VFS_xSetSystemCall_USAGE "VFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool"

#define VFS_xSetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  VFS_xSleep_DOC "VFS.xSleep(microseconds: int) -> int\n\n" \
"Pause execution of the thread for at least the specified number of\n" \
"microseconds (millionths of a second).  This routine is typically called from the busy handler.\n" \
"\n" \
":returns: How many microseconds you actually requested the\n" \
"  operating system to sleep for. For example if your operating\n" \
"  system sleep call only takes seconds then you would have to have\n" \
"  rounded the microseconds number up to the nearest second and\n" \
"  should return that rounded up value.\n" 

#define VFS_xSleep_KWNAMES "microseconds"
#define VFS_xSleep_USAGE "VFS.xSleep(microseconds: int) -> int"

#define VFS_xSleep_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(microseconds), int)); \
} while(0)


#define  Zeroblob_class_DOC "If you want to insert a blob into a row, you need to\n" \
"supply the entire blob in one go.  Using this class or\n" \
"`function <https://www.sqlite.org/lang_corefunc.html#zeroblob>`__\n" \
"allocates the space in the database filling it with zeroes.\n" \
"\n" \
"You can then overwrite parts in smaller chunks, without having\n" \
"to do it all at once.  The :ref:`example <example_blob_io>` shows\n" \
"how to use it.\n" 

#define  Zeroblob_init_DOC "zeroblob.__init__(size: int)\n\n" \
":param size: Number of zeroed bytes to create\n" 

#define Zeroblob_init_KWNAMES "size"
#define Zeroblob_init_USAGE "zeroblob.__init__(size: int)"

#define Zeroblob_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(size), long long)); \
} while(0)


#define  Zeroblob_length_DOC "zeroblob.length() -> int\n\n" \
"Size of zero blob in bytes.\n" 

#define  AbortError_exc_DOC "`SQLITE_ABORT <https://sqlite.org/rescode.html#abort>`__. Callback\n" \
"routine requested an abort.\n" 

#define  AuthError_exc_DOC "`SQLITE_AUTH <https://sqlite.org/rescode.html#auth>`__.\n" \
":attr:`Authorization <Connection.authorizer>` denied.\n" 

#define  BindingsError_exc_DOC "There are several causes for this exception.  When using tuples, an incorrect number of bindings where supplied::\n" \
"\n" \
"   cursor.execute(\"select ?,?,?\", (1,2))     # too few bindings\n" \
"   cursor.execute(\"select ?,?,?\", (1,2,3,4)) # too many bindings\n" \
"\n" \
"You are using named bindings, but not all bindings are named.  You should either use entirely the\n" \
"named style or entirely numeric (unnamed) style::\n" \
"\n" \
"   cursor.execute(\"select * from foo where x=:name and y=?\")\n" 

#define  BusyError_exc_DOC "`SQLITE_BUSY <https://sqlite.org/rescode.html#busy>`__.  The\n" \
"database file is locked.  Use  :meth:`Connection.set_busy_timeout`\n" \
"to change how long SQLite waits for the database to be unlocked or\n" \
":meth:`Connection.set_busy_handler` to use your own handler.\n" 

#define  CantOpenError_exc_DOC "`SQLITE_CANTOPEN <https://sqlite.org/rescode.html#cantopen>`__.\n" \
"Unable to open the database file.\n" 

#define  ConnectionClosedError_exc_DOC "You have called :meth:`Connection.close` and then continued to use\n" \
"the :class:`Connection` or associated :class:`cursors <Cursor>`.\n" 

#define  ConnectionNotClosedError_exc_DOC "This exception is no longer generated.  It was required in earlier\n" \
"releases due to constraints in threading usage with SQLite.\n" 

#define  ConstraintError_exc_DOC "`SQLITE_CONSTRAINT <https://sqlite.org/rescode.html#constraint>`__.\n" \
"Abort due to `constraint\n" \
"<https://sqlite.org/lang_createtable.html>`_ violation.\n" 

#define  CorruptError_exc_DOC "`SQLITE_CORRUPT <https://sqlite.org/rescode.html#corrupt>`__.  The\n" \
"database disk image appears to be a SQLite database but the values\n" \
"inside are inconsistent.\n" 

#define  CursorClosedError_exc_DOC "You have called :meth:`Cursor.close` and then tried to use the cursor.\n" 

#define  EmptyError_exc_DOC "`SQLITE_EMPTY <https://sqlite.org/rescode.html#empty>`__. Not\n" \
"currently used.\n" 

#define  Error_exc_DOC "  This is the base for APSW exceptions.\n" \
"\n" \
".. attribute:: Error.result\n" \
"\n" \
"         For exceptions corresponding to `SQLite error codes\n" \
"         <https://sqlite.org/c3ref/c_abort.html>`_ codes this attribute\n" \
"         is the numeric error code.\n" \
"\n" \
".. attribute:: Error.extendedresult\n" \
"\n" \
"         APSW runs with `extended result codes\n" \
"         <https://sqlite.org/rescode.html>`_ turned on.\n" \
"         This attribute includes the detailed code.\n" \
"\n" \
"         As an example, if SQLite issued a read request and the system\n" \
"         returned less data than expected then :attr:`~Error.result`\n" \
"         would have the value *SQLITE_IOERR* while\n" \
"         :attr:`~Error.extendedresult` would have the value\n" \
"         *SQLITE_IOERR_SHORT_READ*.\n" \
"\n" \
".. attribute:: Error.error_offset\n" \
"\n" \
"        The location of the error in the SQL when encoded in UTF-8.\n" \
"        The value is from `sqlite3_error_offset\n" \
"        <https://www.sqlite.org/c3ref/errcode.html>`__, and will be\n" \
"        `-1` when a specific token in the input is not the cause.\n" 

#define  ExecTraceAbort_exc_DOC "The :ref:`execution tracer <executiontracer>` returned False so\n" \
"execution was aborted.\n" 

#define  ExecutionCompleteError_exc_DOC "Execution of the statements is complete and cannot be run further.\n" 

#define  ExtensionLoadingError_exc_DOC "An error happened loading an `extension\n" \
"<https://sqlite.org/loadext.html>`_.\n" 

#define  ForkingViolationError_exc_DOC "See :meth:`apsw.fork_checker`.\n" 

#define  FormatError_exc_DOC "`SQLITE_FORMAT <https://sqlite.org/rescode.html#format>`__. (No\n" \
"longer used) `Auxiliary database\n" \
"<https://sqlite.org/lang_attach.html>`_ format error.\n" 

#define  FullError_exc_DOC "`SQLITE_FULL <https://sqlite.org/rescode.html#full>`__.  The disk\n" \
"appears to be full.\n" 

#define  IOError_exc_DOC "`SQLITE_IOERR <https://sqlite.org/rescode.html#ioerr>`__.  A disk\n" \
"I/O error occurred.  The :ref:`extended error code <exceptions>`\n" \
"will give more detail.\n" 

#define  IncompleteExecutionError_exc_DOC "You have tried to start a new SQL execute call before executing all\n" \
"the previous ones. See the :ref:`execution model <executionmodel>`\n" \
"for more details.\n" 

#define  InternalError_exc_DOC "`SQLITE_INTERNAL <https://sqlite.org/rescode.html#internal>`__. (No\n" \
"longer used) Internal logic error in SQLite.\n" 

#define  InterruptError_exc_DOC "`SQLITE_INTERRUPT <https://sqlite.org/rescode.html#interrupt>`__.\n" \
"Operation terminated by `sqlite3_interrupt\n" \
"<https://sqlite.org/c3ref/interrupt.html>`_ - use\n" \
":meth:`Connection.interrupt`.\n" 

#define  InvalidContextError_exc_DOC "Context is no longer valid.  Examples include:\n" \
"\n" \
"* Using an :class:`IndexInfo` outside of the :meth:`VTTable.BestIndexObject`\n" \
"  method\n" \
"* Using a registered :class:`FTS5Tokenizer` when the underlying\n" \
"  tokenizer has been deleted/replaced\n" \
"* Using :meth:`Connection.vtab_config` when not inside :meth:`VTModule.Create`\n" \
"* Using a :class:`TableChange` outside of a :meth:`~Changeset.apply` conflict\n" \
"  handler, or when no longer the current :meth:`Changeset.iter` item\n" 

#define  LockedError_exc_DOC "`SQLITE_LOCKED <https://sqlite.org/rescode.html#locked>`__.  Shared\n" \
"cache lock.\n" 

#define  MismatchError_exc_DOC "`SQLITE_MISMATCH <https://sqlite.org/rescode.html#mismatch>`__. Data\n" \
"type mismatch.  For example a rowid or integer primary key must be\n" \
"an integer.\n" 

#define  MisuseError_exc_DOC "`SQLITE_MISUSE <https://sqlite.org/rescode.html#misuse>`__.  SQLite\n" \
"library used incorrectly - typically similar to *ValueError* in\n" \
"Python.  Examples include not having enough flags when opening a\n" \
"connection (eg not including a READ or WRITE flag), or out of spec\n" \
"such as registering a function with more than 127 parameters.\n" 

#define  NoFTS5Error_exc_DOC "The FTS5 extension is not present in SQLite.\n" 

#define  NoLFSError_exc_DOC "`SQLITE_NOLFS <https://sqlite.org/rescode.html#nolfs>`__.  SQLite\n" \
"has attempted to use a feature not supported by the operating system\n" \
"such as `large file support\n" \
"<https://en.wikipedia.org/wiki/Large_file_support>`_.\n" 

#define  NoMemError_exc_DOC "`SQLITE_NOMEM <https://sqlite.org/rescode.html#nomem>`__.  A memory\n" \
" allocation failed.\n" 

#define  NotADBError_exc_DOC "`SQLITE_NOTADB <https://sqlite.org/rescode.html#notadb>`__.  File\n" \
"opened that is not a database file.  SQLite has a header on database\n" \
"files to verify they are indeed SQLite databases.\n" 

#define  NotFoundError_exc_DOC "`SQLITE_NOTFOUND <https://sqlite.org/rescode.html#notfound>`__.\n" \
"Returned when various internal items were not found such as requests\n" \
"for non-existent system calls or file controls.\n" 

#define  PermissionsError_exc_DOC "`SQLITE_PERM <https://sqlite.org/rescode.html#perm>`__. Access\n" \
"permission denied by the operating system.\n" 

#define  ProtocolError_exc_DOC "`SQLITE_PROTOCOL <https://sqlite.org/rescode.html#protocol>`__. (No\n" \
"longer used) Database lock protocol error.\n" 

#define  RangeError_exc_DOC "`SQLITE_RANGE <https://sqlite.org/rescode.html#range>`__.  (Cannot\n" \
"be generated using APSW).  2nd parameter to `sqlite3_bind\n" \
"<https://sqlite.org/c3ref/bind_blob.html>`_ out of range\n" 

#define  ReadOnlyError_exc_DOC "`SQLITE_READONLY <https://sqlite.org/rescode.html#readonly>`__.\n" \
"Attempt to write to a readonly database.\n" 

#define  SQLError_exc_DOC "`SQLITE_ERROR <https://sqlite.org/rescode.html#error>`__.  The\n" \
"standard error code, unless a more specific one is  applicable.\n" 

#define  SchemaChangeError_exc_DOC "`SQLITE_SCHEMA <https://sqlite.org/rescode.html#schema>`__.  The\n" \
"database schema changed.  A  :meth:`prepared statement\n" \
"<Cursor.execute>` becomes invalid if the database schema was\n" \
"changed.  Behind the scenes SQLite reprepares the statement.\n" \
"Another or the same :class:`Connection` may change the schema again\n" \
"before the statement runs.  SQLite will retry before giving up and\n" \
"returning this error.\n" 

#define  ThreadingViolationError_exc_DOC "You have used an object concurrently in two threads. For example you\n" \
"may try to use the same cursor in two different threads at the same\n" \
"time, or tried to close the same connection in two threads at the\n" \
"same time.\n" \
"\n" \
"You can also get this exception by using a cursor while it is\n" \
"already inside execution such as executing a new query while inside\n" \
"a function called by that cursor.  It is recommended to use\n" \
":meth:`Connection.execute` and :meth:`Connection.executemany`\n" \
"instead of using cursors directly.\n" 

#define  TooBigError_exc_DOC "`SQLITE_TOOBIG <https://sqlite.org/rescode.html#toobig>`__.  String\n" \
"or BLOB exceeds size limit.  You can  change the limits using\n" \
":meth:`Connection.limit`.\n" 

#define  VFSFileClosedError_exc_DOC "The VFS file is closed so the operation cannot be performed.\n" 

#define  VFSNotImplementedError_exc_DOC "A call cannot be made to an inherited :ref:`VFS` method as the VFS\n" \
"does not implement the method.\n" 

