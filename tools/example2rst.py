#!/usr/bin/env python3
#
# The purpose of this file is to produce rst output interspersed into
# the the text of the example codes

import contextlib
import sys
import re
import tempfile
import shutil
import io
import pathlib

import apsw.ext

from typing import Any, TextIO

input_name, output_name = sys.argv[1:]

# start of each section in example-code.py
section_re = r"""###\s+(?P<section>\b\w+\b):\s+(?P<desc>.*)\s*"""

# magic string from output to recognise new section
section_marker = "!@#$%^&*()(-:"

# start of rst output
header_example = """\
.. Automatically generated by example2rst.py.  Do not edit this file

.. currentmodule:: apsw

Example/Tour
============

This code demonstrates usage of APSW.  It gives you a good overview of
all the things that can be done.  Also included is output so you can
see what gets printed when you run the code.

There are other dedicated examples:

* :doc:`Async tour <example-async>` for :mod:`asyncio`, |trio|,
  |anyio| etc :doc:`async support <async>`
* :doc:`JSON tour <example-json>` for :doc:`JSON and JSONB support
  <jsonb>`
* :doc:`FTS5 tour <example-fts>` for :doc:`full text search
  <textsearch>`
* :doc:`Session tour <example-session>` for :doc:`session recording
  and playback <session>`

.. code-block:: python
"""

header_fts = """\
.. Automatically generated by example2rst.py.  Do not edit this file

.. currentmodule:: apsw

Full Text Search Example/Tour
=============================

You can do FTS5 using normal SQL `as documented
<https://www.sqlite.org/fts5.html>`__.  This example shows using APSW
specific functionality and extras.

.. code-block:: python

"""

header_session = """\
.. Automatically generated by example2rst.py.  Do not edit this file

.. currentmodule:: apsw

Session Example/Tour
====================

This example shows using APSW to create and use the `Session extension
<https://www.sqlite.org/sessionintro.html>`__

.. code-block:: python

"""

header_json = """\
.. Automatically generated by example2rst.py.  Do not edit this file

.. currentmodule:: apsw

JSON Example/Tour
====================

This example shows using `JSON <json.org>`__ with SQLite, and
additional functionality provided by APSW to make it easier to use.

.. code-block:: python

"""

header_async = """\
.. Automatically generated by example2rst.py.  Do not edit this file

.. currentmodule:: apsw

Async Example/Tour
==================

This shows how to use APSW in :doc:`async <async>` node.
:mod:`asyncio`, |trio|, and |anyio| are supported.  A different one is
used for each block, although they all work.

.. note::

    You don't have to make all connections exclusively sync or async,
    and can mix and match as needed.  SQLite is fast, and in many
    cases there may not be a benefit to concurrency with async.

.. code-block:: python

"""

header = {
    "examples/main.py": header_example,
    "examples/fts.py": header_fts,
    "examples/session.py": header_session,
    "examples/json.py": header_json,
    "examples/async.py": header_async,
}[input_name]

# this is used when generating the X in index directives
# and should include its following space
# eg .. index:: Timeouts (X example code)
index_name ={
    "examples/main.py": "",
    "examples/fts.py": "Full text search ",
    "examples/session.py": "Session ",
    "examples/json.py": "JSON ",
    "examples/async.py": "Async ",
}[input_name]


fractal_sql = """
    WITH RECURSIVE
    xaxis(x) AS (VALUES(-2.0) UNION ALL SELECT x+0.05 FROM xaxis WHERE x<1.2),
    yaxis(y) AS (VALUES(-1.0) UNION ALL SELECT y+0.1 FROM yaxis WHERE y<1.0),
    m(iter, cx, cy, x, y) AS (
        SELECT 0, x, y, 0.0, 0.0 FROM xaxis, yaxis
        UNION ALL
        SELECT iter+1, cx, cy, x*x-y*y + cx, 2.0*x*y + cy FROM m
        WHERE (x*x + y*y) < 4.0 AND iter< 800000 -- this should be 28 and controls how much work is done
    ),
    m2(iter, cx, cy) AS (
        SELECT max(iter), cx, cy FROM m GROUP BY cx, cy
    ),
    a(t) AS (
        SELECT group_concat( substr(' .+*#', 1+min(iter/7,4), 1), '')
        FROM m2 GROUP BY cy
    )
    SELECT group_concat(rtrim(t),x'0a') FROM a;"""


replacements = {
    'pathlib.Path("session.sql")': 'pathlib.Path("doc/_static/samples/session.sql")',
    'fractal_sql = "outlandish fractal"': 'fractal_sql = "' + fractal_sql.replace("\n", "\\n") + '"',
    'query = "fractal"': 'query = "' + fractal_sql.replace("\n", "\\n").replace("800000", "28") + '"',
}

class TeeStringIO(io.StringIO):
    def __init__(self, tee: TextIO):
        super().__init__()
        self.tee = tee

    def write(self, s: str) -> int:
        if s.startswith(section_marker):
            self.tee.write("\nSECTION "+s[len(section_marker):])
        else:
            self.tee.write(s)
        return super().write(s)

    def writelines(self, lines: Iterable[str]) -> None:
        # hopefully don't need to implement this
        raise NotImplementedError

def get_output(filename: str):
    code: list[str] = []
    for line in pathlib.Path(filename).read_text().splitlines():
        mo = re.match(section_re, line)
        if mo:
            code.append(f"apsw.config(apsw.SQLITE_CONFIG_LOG, None) ; print('{section_marker}{mo.group('section')}')")
            continue
        for k, v in replacements.items():
            if k in line:
                line = line.replace(k, v)
        code.append(line)

    code: str = "\n".join(code) + "\n"

    output: dict[str, list[str]] = {}
    cur_section = None

    if False:  # make True if you need to debug the changes
        print(code)

    my_io = TeeStringIO(sys.stdout)

    with contextlib.redirect_stdout(my_io):
        with contextlib.redirect_stderr(my_io):
            exec(compile(code, filename, "exec"), {})

    for line in my_io.getvalue().splitlines():
        if line.startswith(section_marker):
            cur_section = line[len(section_marker) :]
            output[cur_section] = []
            continue
        output[cur_section].append(line)

    return output


def gen_rst(filename: str, outfile: TextIO, output: dict[str, list[str]]) -> None:
    print(header, file=outfile)
    cur_section = None
    seen_blank = True

    with open(filename, "rt") as source:
        for num, line in enumerate(source):
            mo = re.match(section_re, line)
            if mo:
                if cur_section and output[cur_section]:
                    print("\n\n.. code-block:: output\n", file=outfile)
                    for l in output[cur_section]:
                        print("    " + l, file=outfile)
                    print("", file=outfile)
                cur_section = mo.group("section")
                print(f"\n.. index:: {mo.group('desc')} ({index_name}example code)\n", file=outfile)
                print(f".. _example_{cur_section}:\n", file=outfile)
                print(mo.group("desc"), file=outfile)
                print("-" * len(mo.group("desc")), file=outfile)
                print("", file=outfile)
                seen_blank = False
                continue

            if not seen_blank:
                if not line.strip():
                    seen_blank = True
                    print("\n.. code-block:: python\n", file=outfile)
                else:
                    l = line.rstrip()
                    l = l.lstrip("#")[1:]
                    print(l, file=outfile)
                continue
            print("   " + line.rstrip(), file=outfile)

    f.flush()


if __name__ == "__main__":
    try:
        output = get_output(input_name)
    except:
        apsw.ext.print_augmented_traceback(*sys.exc_info())
        raise
    with tempfile.NamedTemporaryFile("wt", prefix="example2rst") as f:
        gen_rst(input_name, f, output)
        shutil.copy(f.name, output_name)
