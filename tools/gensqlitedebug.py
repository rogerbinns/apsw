#!/usr/bin/env python3

import pathlib
import subprocess
import sys
import urllib.request
from pprint import pprint
from re import fullmatch

import apsw
import apsw.ext

header = """/* generated by gensqlitedebug.py - edit that not this */

#define DBMUTEX_ASSERT(x) do { } while(0)

/* This file generates alternate sqlite functions that help
   check code correctness.  See issue 551 where we want to
   verify the database mutex is held */

#if !defined(NDEBUG) && defined(SQLITE_DEBUG) && defined(APSW_DEBUG)

#undef DBMUTEX_ASSERT
#define DBMUTEX_ASSERT(x) do { assert(sqlite3_mutex_held(sqlite3_db_mutex((x)))); } while(0)

"""

footer = """
#endif
"""

# functions_ define how we use functions, with the goal of getting the
# per database sqlite3* so we can assert the mutex is held.  they are
# searched in the in the declaration order below

# these are not used in the codebase
functions_not_used = (
    "sqlite3_.*16(|_v2|_v3)",
    "sqlite3_snapshot_.*",
    "sqlite3_(cancel_|reset_|)auto_extension",
    "sqlite3_bind_(blob|int|text|value|parameter_index|zeroblob)",
    "sqlite3_changes",
    "sqlite3_close_v2",
    "sqlite3_column_int",
    "sqlite3_compileoption_used",
    "sqlite3_create_collation",
    "sqlite3_create_filename",
    "sqlite3_create_function",
    "sqlite3_create_module",
    "sqlite3_database_file_object",
    "sqlite3_errcode",
    "sqlite3_filename_database",
    "sqlite3_free_(filename|table)",
    "sqlite3_(get|set)_(auxdata|clientdata|table)",
    "sqlite3_keyword_check",
    "sqlite3_libversion_number",
    # 64 should be used
    "sqlite3_malloc",
    # we use python reallocs
    "sqlite3_realloc.*",
    "sqlite3_msize",
    "sqlite3_prepare(|_v2)",
    "sqlite3_(snprintf|vmprintf|vsnprintf)",
    # v2 should be used
    "sqlite3changeset_apply(|_strm)",
    # try should be used not enter
    "sqlite3_mutex_(alloc|enter|free|notheld)",
    "sqlite3_next_stmt",
    "sqlite3_normalized_sql",
    "sqlite3_open",
    "sqlite3_os_(init|end)",
    "sqlite3_result_(blob|error_toobig|int|subtype|text|text16.*|value|zeroblob)",
    "sqlite3_status",
    "sqlite3_stmt_busy",
    "sqlite3_stmt_scanstatus(|_reset|_v2)",
    "sqlite3_str_.*",
    "sqlite3_test_control",
    "sqlite3_total_changes",
    "sqlite3_unlock_notify",
    "sqlite3_value_(int|dup|encoding|free|frombind|numeric_type|subtype|text16be|text16le)",
    "sqlite3_version",  # we use sqlite3_libversion
    "sqlite3_wal_checkpoint",
    "sqlite3_win32_set_directory.*",
)

# used for debugging etc
functions_special = (
    "sqlite3_context_db_handle",
    "sqlite3_db_handle",
    "sqlite3_mutex_held",
)

# these do not have a per database mutex
functions_global = (
    "sqlite3session_.*",
    "sqlite3_errstr",
    "sqlite3_libversion",
    "sqlite3_libversion_number",
    "sqlite3_compileoption_.*",
    "sqlite3_complete",
    "sqlite3_config",
    "sqlite3_(malloc|malloc|free|realloc)(|64)",
    "sqlite3_enable_shared_cache",
    # used during open and no need to check mutex
    "sqlite3_extended_result_codes",
    "sqlite3_hard_heap_limit64",
    "sqlite3_initialize",
    # interrupt could in theory race with close if we release GIL for close
    "sqlite3_interrupt",
    "sqlite3_keyword_.*",
    "sqlite3_log",
    "sqlite3_memory_(highwater|used)",
    "sqlite3_mprintf",
    "sqlite3_open_v2",
    "sqlite3_randomness",
    "sqlite3_release_memory",
    "sqlite3_shutdown",
    "sqlite3_sleep",
    "sqlite3_soft_heap_limit64",
    "sqlite3_sourceid",
    "sqlite3_status64",
    "sqlite3_str(glob|icmp|like|nicmp)",
    "sqlite3_system_errno",
    "sqlite3_threadsafe",
    "sqlite3_vfs_(find|register|unregister)",
    "sqlite3_vtab_(collation|distinct|in|in_next|in_first|rhs_value)",
    "sqlite3_win32_.*",
    # there can't be a dangling refcount on the connection (assertion failure)
    "sqlite3_close",
    # next group don't do any mutexes in sqlite3.c hence don't make
    # any sense for us to.  they generally read or write a single value.
    "sqlite3_bind_parameter_count",
    "sqlite3_backup_(pagecount|remaining)",
    "sqlite3_blob_bytes",
    "sqlite3_changes64",
    "sqlite3_get_autocommit",
    "sqlite3_is_interrupted",
    "sqlite3_last_insert_rowid",
    "sqlite3_limit",
    "sqlite3_total_changes64",
    "sqlite3_stmt_(isexplain|readonly)",
    # can't get to db from these
    "sqlite3_filename_(database|journal|wal)",
    "sqlite3_uri_.*",
    "sqlite3_value_.*",
    # needs manual work ::TODO:: check these are done right
    "sqlite3_blob_close",
    "sqlite3_backup_finish",
    # used below so we can't redefine
    "sqlite3_context_db_handle",
    "sqlite3_db_handle",
    "sqlite3_db_mutex",
    "sqlite3_mutex_held",
    "sqlite3_mutex_(try|leave)",
    # session extension
    "sqlite3change(group|set)_.*",
    "sqlite3rebaser_.*",
)

# name pattern, number of args, how to get sqlite3* ideally avoiding
# our own Python data structures to make sure we are correct with
# those
functions_arg = (
    # has a context
    ("sqlite3_aggregate_context", 2, "sqlite3_context_db_handle((one))"),
    ("sqlite3_user_data", 1, "sqlite3_context_db_handle((one))"),
    ("sqlite3_vtab_nochange", 1, "sqlite3_context_db_handle((one))"),
    ("sqlite3_backup_init", 4, None),
    # statement stuff
    ("sqlite3_bind_parameter_count", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_bind_(null|parameter_name)", 2, "sqlite3_db_handle((one))"),
    ("sqlite3_bind_(double|int64|zeroblob64)", 3, "sqlite3_db_handle((one))"),
    ("sqlite3_bind_(blob64|pointer)", 5, "sqlite3_db_handle((one))"),
    ("sqlite3_bind_text64", 6, "sqlite3_db_handle((one))"),
    ("sqlite3_clear_bindings", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_column_count", 1, "sqlite3_db_handle((one))"),
    (
        "sqlite3_column_(blob|double|int64|text|bytes|type|database_name|table_name|origin_name|decltype|name|value)",
        2,
        "sqlite3_db_handle((one))",
    ),
    ("sqlite3_data_count", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_expanded_sql", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_finalize", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_reset", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_sql", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_step", 1, "sqlite3_db_handle((one))"),
    ("sqlite3_stmt_explain", 2, "sqlite3_db_handle((one))"),
    ("sqlite3_stmt_status", 3, "sqlite3_db_handle((one))"),
    # returning values
    ("sqlite3_result_(error_nomem|null)", 1, "sqlite3_context_db_handle((one))"),
    ("sqlite3_result_(double|error_code|int64|zeroblob64)", 2, "sqlite3_context_db_handle((one))"),
    ("sqlite3_result_error", 3, "sqlite3_context_db_handle((one))"),
    ("sqlite3_result_(blob64|pointer)", 4, "sqlite3_context_db_handle((one))"),
    ("sqlite3_result_text64", 5, "sqlite3_context_db_handle((one))"),
)

# the first parameter is sqlite3*.  key is number of args taken
functions_arg_one = {
    1: (
        "sqlite3_db_cacheflush",
        "sqlite3_db_release_memory",
        "sqlite3_(errcode|errmsg|error_offset|extended_errcode)",
        "sqlite3_vtab_on_conflict",
        "sqlite3_preupdate_count",
        "sqlite3_preupdate_depth",
        "sqlite3_preupdate_blobwrite",
    ),
    2: (
        "sqlite3_busy_timeout",
        "sqlite3_db_(file|)name",
        "sqlite3_db_readonly",
        "sqlite3_declare_vtab",
        "sqlite3_drop_modules",
        "sqlite3_enable_load_extension",
        "sqlite3_set_last_insert_rowid",
        "sqlite3_txn_state",
        "sqlite3_wal_autocheckpoint",
    ),
    3: (
        "sqlite3_busy_handler",
        "sqlite3_collation_needed",
        "sqlite3_(commit|rollback)_hook",
        "sqlite3_overload_function",
        "sqlite3_set_authorizer",
        "sqlite3_update_hook",
        "sqlite3_vtab_config",
        "sqlite3_wal_hook",
        "sqlite3_setlk_timeout",
        "sqlite3_preupdate_hook",
        "sqlite3_preupdate_old",
        "sqlite3_preupdate_new",
    ),
    4: (
        "sqlite3_autovacuum_pages",
        # db_config takes variable number of args, but we always use 4
        "sqlite3_db_config",
        "sqlite3_file_control",
        "sqlite3_load_extension",
        "sqlite3_progress_handler",
        "sqlite3_serialize",
        "sqlite3_trace_v2",
    ),
    5: (
        "sqlite3_create_module_v2",
        "sqlite3_db_status",
        "sqlite3_exec",
        "sqlite3_wal_checkpoint_v2",
    ),
    6: (
        "sqlite3_create_collation_v2",
        "sqlite3_deserialize",
        "sqlite3_prepare_v3",
    ),
    7: ("sqlite3_blob_open",),
    9: (
        "sqlite3_create_function_v2",
        "sqlite3_table_column_metadata",
    ),
    10: ("sqlite3_create_window_function",),
}

# name pattern, how to get sqlite3*
functions = (
    ("sqlite3_backup_.*", None),
    ("sqlite3_blob_.*", "self->connection->db"),
)

ifdefs = {
    "SQLITE_ENABLE_COLUMN_METADATA": "sqlite3_column_(database|table|origin)_.*",
}

arg_names = ("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")


def call_args(n):
    return ", ".join(f"({a})" for a in arg_names[:n])


def code_for_name(name: str):
    for pattern in functions_not_used:
        if fullmatch(pattern, name):
            # cause a compilation error if we try to use these
            return f"#undef {name}\n#define {name} *not used*"

    for pattern in functions_global:
        if fullmatch(pattern, name):
            return ""

    for pattern, nargs, dbget in functions_arg:
        assert nargs <= len(arg_names)
        if fullmatch(pattern, name):
            if name == "sqlite3_backup_init":
                check = "sqlite3_mutex_held(sqlite3_db_mutex(one)) && sqlite3_mutex_held(sqlite3_db_mutex(three))"
            else:
                check = f"sqlite3_mutex_held(sqlite3_db_mutex({dbget}))"
            return f"""
#define {name}({", ".join(arg_names[:nargs])}) ({{
    assert ({check});
    {name}({call_args(nargs)});
}})
"""

    for nargs, patterns in functions_arg_one.items():
        for pattern in patterns:
            if fullmatch(pattern, name):
                return f"""
#define {name}({", ".join(arg_names[:nargs])}) ({{
    assert (sqlite3_mutex_held(sqlite3_db_mutex(one)));
    {name}({call_args(nargs)});
}})
"""

    for pattern, dbget in functions:
        if fullmatch(pattern, name):
            if fullmatch("sqlite3_backup_.*", name):
                check = "sqlite3_mutex_held(sqlite3_db_mutex(self->dest->db)) && sqlite3_mutex_held(sqlite3_db_mutex(self->source->db))"
            else:
                check = f"sqlite3_mutex_held(sqlite3_db_mutex({dbget}))"
            return f"""
#define {name}(...) ({{
    assert ({check});
    {name}(__VA_ARGS__);
}})
"""
    raise Exception(f"Unknown {name=}")


basesqurl = "https://sqlite.org/"

db = apsw.Connection("")
db.deserialize("main", urllib.request.urlopen(basesqurl + "toc.db").read())


db.execute(open("tools/tocupdate.sql", "rt").read())


# ::TODO:: all callers of convert_value_to_pyobject need to assert mutex held
# ::TODO:: sqlitw3_blob_close needs manual check
# ::TODO:: sqlitw3_backup_finish needs manual check


def backslash(text: str) -> str:
    if text.startswith("#undef"):
        return text
    lines = text.splitlines()
    l = max(len(line) for line in lines) + 2
    res = ""
    for line in lines[:-1]:
        res += line + " " * (l - len(line)) + "\\\n"
    res += lines[-1]
    return res


code = header

for (name,) in db.execute("select name from toc where type='function' and status < 2 order by name"):
    res = code_for_name(name).rstrip().lstrip("\n")
    if res:
        ifdef = None
        for defname, pattern in ifdefs.items():
            if fullmatch(pattern, name):
                ifdef = defname
                break

        if ifdef:
            code += f"#ifdef {ifdef}\n"
        code += backslash(res) + "\n"
        if ifdef:
            code += "#endif\n"
        code += "\n"


code += footer

f = pathlib.Path("src/sqlite_debug.h")
if not f.exists() or f.read_text() != code:
    f.write_text(code)


# find_unwrapped stuff from here on
db.row_trace = apsw.ext.DataClassRowFactory(dataclass_kwargs={"frozen": True})

functions = set(
    row.name
    for row in db.execute("""
    SELECT * FROM toc WHERE type = 'function' AND status = 0
"""))

missing= []
unexpected = []

for f in sorted(functions):
    if f in functions_special:
        continue
    # we have to exclude this file ...
    res = subprocess.run(["git", "grep", "-wFq", f, "--", "*.c"])
    assert res.returncode >= 0

    for pat in functions_not_used:
        if fullmatch(pat, f):
            if res.returncode == 0:
                unexpected.append(f)
            break
    else:
        if res.returncode != 0:
            missing.append(f)


if missing:
    print("Expected code mention in C files")
    pprint(missing)

if unexpected:
    print("In functions not_used, but is mentioned in C files")
    pprint(unexpected)

if missing or unexpected:
    sys.exit(1)